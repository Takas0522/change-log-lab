# 結合テストシナリオ: 高機能ToDoアプリケーション

**文書ID**: ITS-001  
**バージョン**: 1.0  
**作成日**: 2025-01-31  
**ステータス**: Draft

---

## 1. 概要

### 1.1 目的

本文書は、高機能ToDoアプリケーション（todo-app）の結合テストシナリオを定義するものである。システムの全コンポーネント（Frontend、Backend、Database）が統合された状態で、機能要件および非機能要件を満たすことを検証する。

**検証目的:**
- システム全体の統合動作検証
- コンポーネント間のインターフェース検証
- エンドツーエンドの業務フローの検証
- 非機能要件（性能、セキュリティ、ユーザビリティ）の検証

### 1.2 対象範囲

**対象コンポーネント:**
- Frontend: Angular SPA (`/src/todo-app/front`)
- Backend: ASP.NET Core REST API (`/src/todo-app/api`)
- Database: SQL Database (`/src/todo-app/database`)

**対象要件:**
- 機能要件: REQ-FUNC-001 ～ REQ-FUNC-017（17件すべて）
- 非機能要件: 性能（REQ-PERF-001～008）、セキュリティ（REQ-SEC-001～006）、ユーザビリティ（REQ-USE-001～008）

### 1.3 参照資料

- **要求仕様書**: `docs/todo-app/要求定義/SRS-001-todo-app.md` (v2.0)
- **詳細設計書**: `docs/todo-app/詳細設計/SDD-001-todo-app.md` (v2.0)
- IEEE 829: Standard for Software and System Test Documentation
- ISTQB Integration Test Level

---

## 2. テスト環境

### 2.1 環境構成

| 項目 | 内容 |
|---|---|
| **Frontend** | Angular 17+, TypeScript 5.0+, RxJS 7.8+, Angular Material 17+ |
| **Backend** | ASP.NET Core 8.0+, C# 12.0+, Entity Framework Core 8.0+ |
| **Database** | SQL Server 2022+ / Azure SQL Database |
| **HTTPクライアント** | Angular HttpClient with Interceptors |
| **テスト実行環境** | 開発環境またはステージング環境 |
| **ネットワーク** | 10Mbps以上の帯域 |
| **ブラウザ** | Chrome最新版、Edge最新版、Firefox最新版、Safari最新版 |

### 2.2 テストデータ準備

| データ種別 | 件数 | 備考 |
|---|---|---|
| **基本ToDo** | 100件 | 各ステータスに分散（未着手40件、着手中30件、完了20件、放棄10件） |
| **大量ToDo** | 100万件 | 性能テスト用（REQ-PERF-006, 008対応） |
| **基本ラベル** | 20件 | 8色のプリセットカラーを含む |
| **ToDo-ラベル紐付け** | 平均2.5個/ToDo | ラベルなしToDoも含む |
| **長文ToDo** | 10件 | タイトル200文字、内容5000文字 |
| **検索用ToDo** | 50件 | 特定キーワードを含むテストデータ |

### 2.3 事前条件

- データベースがクリーンな状態で初期化されていること
- テストデータが投入されていること
- フロントエンドとバックエンドが正常に起動していること
- HTTPSが有効化されていること

---

## 3. 機能統合テスト

### 3.1 ToDo CRUD統合シナリオ

#### TC-IT-001: ToDo作成から削除までの一連のフロー

| 項目 | 内容 |
|---|---|
| **対象要件** | REQ-FUNC-001, 002, 003, 004, 005 |
| **目的** | ToDoのCRUD操作が統合して正常に動作することを検証 |
| **前提条件** | ・ブラウザでアプリケーションにアクセス済み<br>・初期データとして10件のToDoが存在 |
| **テスト手順** | **1. ToDo作成（REQ-FUNC-001）**<br>&nbsp;&nbsp;1-1. 一覧画面で「新規作成」ボタンをクリック<br>&nbsp;&nbsp;1-2. タイトルに「結合テスト_ToDo作成」を入力<br>&nbsp;&nbsp;1-3. 内容に「統合テストのための作成テスト」を入力<br>&nbsp;&nbsp;1-4. ステータスを「未着手」に設定<br>&nbsp;&nbsp;1-5. 「保存」ボタンをクリック<br><br>**2. 一覧表示確認（REQ-FUNC-002）**<br>&nbsp;&nbsp;2-1. 一覧画面にリダイレクトされることを確認<br>&nbsp;&nbsp;2-2. 作成したToDoが一覧の先頭に表示されることを確認<br>&nbsp;&nbsp;2-3. タイトル、ステータス、投稿日時が正しく表示されることを確認<br><br>**3. 詳細表示（REQ-FUNC-003）**<br>&nbsp;&nbsp;3-1. 作成したToDoをクリック<br>&nbsp;&nbsp;3-2. 詳細画面に遷移することを確認<br>&nbsp;&nbsp;3-3. タイトル、内容、ステータス、投稿日時がすべて正しく表示されることを確認<br><br>**4. ToDo更新（REQ-FUNC-004）**<br>&nbsp;&nbsp;4-1. 詳細画面で「編集」ボタンをクリック<br>&nbsp;&nbsp;4-2. タイトルを「結合テスト_ToDo更新後」に変更<br>&nbsp;&nbsp;4-3. 内容を「更新テストの確認」に変更<br>&nbsp;&nbsp;4-4. ステータスを「着手中」に変更<br>&nbsp;&nbsp;4-5. 「保存」ボタンをクリック<br>&nbsp;&nbsp;4-6. 詳細画面に戻り、変更内容が反映されていることを確認<br>&nbsp;&nbsp;4-7. 一覧画面に戻り、更新内容が反映されていることを確認<br><br>**5. ToDo削除（REQ-FUNC-005）**<br>&nbsp;&nbsp;5-1. 詳細画面で「削除」ボタンをクリック<br>&nbsp;&nbsp;5-2. 確認ダイアログが表示されることを確認<br>&nbsp;&nbsp;5-3. 「はい」をクリック<br>&nbsp;&nbsp;5-4. 一覧画面にリダイレクトされることを確認<br>&nbsp;&nbsp;5-5. 削除したToDoが一覧に表示されないことを確認 |
| **期待結果** | **1. 作成時:**<br>・成功メッセージ「ToDoを作成しました」が表示される<br>・作成日時が自動設定される<br>・ToDoIDが自動採番される<br>・レスポンス時間が500ms以内<br><br>**2. 一覧表示時:**<br>・総件数が11件になる<br>・作成したToDoが最上部に表示される<br>・レスポンス時間が1秒以内<br><br>**3. 詳細表示時:**<br>・全フィールドが正しく表示される<br>・レスポンス時間が300ms以内<br><br>**4. 更新時:**<br>・成功メッセージ「ToDoを更新しました」が表示される<br>・更新日時が自動更新される<br>・レスポンス時間が500ms以内<br><br>**5. 削除時:**<br>・成功メッセージ「ToDoを削除しました」が表示される<br>・一覧に表示されなくなる<br>・DB上ではIsDeleted=1で論理削除される<br>・レスポンス時間が300ms以内 |
| **確認ポイント** | ・各API呼び出しが正常に完了すること<br>・Frontend-Backend間のデータ連携が正しいこと<br>・Database上のデータが正しく保存・更新・論理削除されること<br>・各画面遷移が正しく機能すること<br>・エラーハンドリングが適切であること |
| **テストデータ** | ・作成するToDo: タイトル最大200文字、内容最大5000文字以内のバリエーション |

#### TC-IT-002: ToDo作成時のバリデーション統合テスト

| 項目 | 内容 |
|---|---|
| **対象要件** | REQ-FUNC-001, REQ-SEC-005 |
| **目的** | クライアント側とサーバー側のバリデーションが統合して動作することを検証 |
| **前提条件** | ToDo作成画面が表示されている |
| **テスト手順** | **1. タイトル未入力エラー**<br>&nbsp;&nbsp;1-1. タイトルを空欄のまま「保存」をクリック<br>&nbsp;&nbsp;1-2. エラーメッセージが表示されることを確認<br>&nbsp;&nbsp;1-3. フォーカスがタイトル入力欄に移動することを確認<br><br>**2. タイトル長超過エラー**<br>&nbsp;&nbsp;2-1. タイトルに201文字の文字列を入力<br>&nbsp;&nbsp;2-2. リアルタイムバリデーションでエラー表示されることを確認<br>&nbsp;&nbsp;2-3. 「保存」をクリックしてもサーバー側でエラーとなることを確認<br><br>**3. 内容長超過エラー**<br>&nbsp;&nbsp;3-1. 内容に5001文字の文字列を入力<br>&nbsp;&nbsp;3-2. リアルタイムバリデーションでエラー表示されることを確認<br>&nbsp;&nbsp;3-3. 「保存」をクリックしてもサーバー側でエラーとなることを確認<br><br>**4. 無効なステータスエラー**<br>&nbsp;&nbsp;4-1. ブラウザの開発者ツールでステータス値を「InvalidStatus」に改ざん<br>&nbsp;&nbsp;4-2. 「保存」をクリック<br>&nbsp;&nbsp;4-3. サーバー側でバリデーションエラーとなることを確認<br><br>**5. 正常ケース**<br>&nbsp;&nbsp;5-1. すべての入力項目を正しく入力<br>&nbsp;&nbsp;5-2. 「保存」をクリックして成功することを確認 |
| **期待結果** | **1. タイトル未入力:**<br>・クライアント側エラー: 「タイトルは必須です」<br>・保存リクエストが送信されない<br><br>**2. タイトル長超過:**<br>・クライアント側エラー: 「タイトルは200文字以内で入力してください」<br>・サーバー側エラー(400): "Title must not exceed 200 characters"<br><br>**3. 内容長超過:**<br>・クライアント側エラー: 「内容は5000文字以内で入力してください」<br>・サーバー側エラー(400): "Content must not exceed 5000 characters"<br><br>**4. 無効なステータス:**<br>・サーバー側エラー(400): "Invalid status value"<br><br>**5. 正常ケース:**<br>・201 Created<br>・成功メッセージ表示 |
| **確認ポイント** | ・クライアント側バリデーションが機能すること<br>・サーバー側バリデーションが必ず実行されること（クライアント側バリデーションのバイパス対策）<br>・エラーメッセージがユーザーフレンドリーであること<br>・REQ-USE-005（エラーメッセージの理解可能性）を満たすこと |
| **関連要件** | REQ-FUNC-001, REQ-SEC-005, REQ-USE-005, REQ-USE-006 |


### 3.2 ステータス遷移統合シナリオ

#### TC-IT-010: ステータス変更の統合フロー

| 項目 | 内容 |
|---|---|
| **対象要件** | REQ-FUNC-006, REQ-FUNC-007 |
| **目的** | ToDoのステータス変更とビジュアル表示が正しく連携することを検証 |
| **前提条件** | ステータスが「未着手」のToDoが1件存在する |
| **テスト手順** | **1. 未着手→着手中**<br>&nbsp;&nbsp;1-1. 詳細画面を開く<br>&nbsp;&nbsp;1-2. ステータスドロップダウンから「着手中」を選択<br>&nbsp;&nbsp;1-3. 「保存」をクリック<br>&nbsp;&nbsp;1-4. ステータスの色が青系に変わることを確認<br>&nbsp;&nbsp;1-5. 一覧画面に戻ってステータス表示を確認<br><br>**2. 着手中→完了**<br>&nbsp;&nbsp;2-1. 詳細画面を開く<br>&nbsp;&nbsp;2-2. ステータスドロップダウンから「完了」を選択<br>&nbsp;&nbsp;2-3. 「保存」をクリック<br>&nbsp;&nbsp;2-4. ステータスの色が緑系に変わることを確認<br>&nbsp;&nbsp;2-5. 一覧画面でステータス表示を確認<br><br>**3. 着手中→放棄**<br>&nbsp;&nbsp;3-1. 新しいToDoを作成しステータスを「着手中」に設定<br>&nbsp;&nbsp;3-2. ステータスを「放棄」に変更<br>&nbsp;&nbsp;3-3. ステータスの色が赤系に変わることを確認<br><br>**4. ステータスによる絞込（REQ-FUNC-015）**<br>&nbsp;&nbsp;4-1. 一覧画面でステータスフィルターを「完了」のみに設定<br>&nbsp;&nbsp;4-2. 完了ステータスのToDoのみが表示されることを確認 |
| **期待結果** | ・各ステータスの色が正しく表示される（未着手:グレー、着手中:青、完了:緑、放棄:赤）<br>・ステータスアイコンが表示される（色覚異常者対応）<br>・ステータス変更がリアルタイムに反映される<br>・レスポンス時間が300ms以内<br>・一覧画面とのステータス表示が一致する |
| **確認ポイント** | ・Frontend-Backendのステータス値の整合性<br>・UI表示の視覚的フィードバック<br>・アクセシビリティ対応（WCAG 2.1 Level AA） |
| **関連要件** | REQ-FUNC-006, 007, 015, REQ-USE-008 |

### 3.3 ラベル機能統合シナリオ

#### TC-IT-020: ラベル作成とToDo紐付けの統合フロー

| 項目 | 内容 |
|---|---|
| **対象要件** | REQ-FUNC-008, 009, 012, 013 |
| **目的** | ラベル作成からToDo紐付け、絞込までの一連のフローを検証 |
| **前提条件** | ・ToDoが5件存在<br>・ラベルが3件存在 |
| **テスト手順** | **1. ラベル作成（REQ-FUNC-008）**<br>&nbsp;&nbsp;1-1. ラベル管理画面を開く<br>&nbsp;&nbsp;1-2. 「新規ラベル」ボタンをクリック<br>&nbsp;&nbsp;1-3. ラベル名に「結合テスト用ラベル」を入力<br>&nbsp;&nbsp;1-4. プリセットから赤色（#FF0000）を選択<br>&nbsp;&nbsp;1-5. 「保存」をクリック<br><br>**2. ラベル一覧確認（REQ-FUNC-009）**<br>&nbsp;&nbsp;2-1. ラベル一覧に作成したラベルが表示されることを確認<br>&nbsp;&nbsp;2-2. 使用中のToDo件数が0件と表示されることを確認<br>&nbsp;&nbsp;2-3. ラベル名昇順でソートされていることを確認<br><br>**3. ToDoへのラベル設定（REQ-FUNC-012）**<br>&nbsp;&nbsp;3-1. ToDo詳細画面を開く<br>&nbsp;&nbsp;3-2. ラベル選択UI（マルチセレクト）を開く<br>&nbsp;&nbsp;3-3. 「結合テスト用ラベル」を含む3つのラベルを選択<br>&nbsp;&nbsp;3-4. 「保存」をクリック<br>&nbsp;&nbsp;3-5. 詳細画面にラベルが3つ表示されることを確認<br>&nbsp;&nbsp;3-6. 各ラベルの色が正しく表示されることを確認<br><br>**4. ラベルによる絞込（REQ-FUNC-013）**<br>&nbsp;&nbsp;4-1. 一覧画面でラベルフィルターを開く<br>&nbsp;&nbsp;4-2. 「結合テスト用ラベル」を選択<br>&nbsp;&nbsp;4-3. 該当するToDoのみが表示されることを確認<br>&nbsp;&nbsp;4-4. ヒット件数が正しく表示されることを確認<br><br>**5. 複数ラベル選択（OR条件）**<br>&nbsp;&nbsp;5-1. 「結合テスト用ラベル」と既存ラベルを2つ選択<br>&nbsp;&nbsp;5-2. いずれかのラベルを持つToDoが表示されることを確認（OR条件）<br><br>**6. ラベル削除の影響確認（REQ-FUNC-011）**<br>&nbsp;&nbsp;6-1. ラベル管理画面で「結合テスト用ラベル」を削除<br>&nbsp;&nbsp;6-2. 使用中の警告メッセージが表示されることを確認<br>&nbsp;&nbsp;6-3. 削除実行<br>&nbsp;&nbsp;6-4. ToDo詳細画面でラベルが除去されていることを確認 |
| **期待結果** | **1. ラベル作成:**<br>・成功メッセージ表示<br>・LabelIDが自動採番される<br>・レスポンス時間300ms以内<br><br>**2. ラベル一覧:**<br>・全ラベルが昇順表示<br>・使用中ToDo件数が正確<br>・レスポンス時間500ms以内<br><br>**3. ラベル設定:**<br>・最大10個まで設定可能<br>・11個目を選択するとエラーメッセージ表示<br>・レスポンス時間500ms以内<br><br>**4. 絞込:**<br>・OR条件で正しく絞込<br>・レスポンス時間1秒以内<br><br>**5. ラベル削除:**<br>・使用中の警告が表示される<br>・削除後、TodoLabel中間テーブルから紐付けが削除される |
| **確認ポイント** | ・多対多の中間テーブル（TodoLabel）が正しく機能すること<br>・ラベルの色表示が正しいこと<br>・ラベル削除時のカスケード削除が動作すること<br>・最大10個のラベル制限が機能すること |
| **関連要件** | REQ-FUNC-008, 009, 010, 011, 012, 013 |

#### TC-IT-021: ラベル名重複チェック

| 項目 | 内容 |
|---|---|
| **対象要件** | REQ-FUNC-008 |
| **目的** | ラベル名のユニーク制約が正しく機能することを検証 |
| **前提条件** | 「仕事」というラベルが既に存在する |
| **テスト手順** | 1. ラベル作成画面で、ラベル名に「仕事」を入力<br>2. 色を選択して「保存」をクリック<br>3. エラーメッセージが表示されることを確認 |
| **期待結果** | ・400 Bad Request<br>・エラーメッセージ: 「このラベル名は既に使用されています」<br>・データベースにデータが保存されない |
| **確認ポイント** | ・データベースのユニーク制約が機能すること<br>・サーバー側でのバリデーションが機能すること |
| **関連要件** | REQ-FUNC-008, REQ-SEC-005 |

### 3.4 検索・絞込統合シナリオ

#### TC-IT-030: 複合絞込の統合フロー

| 項目 | 内容 |
|---|---|
| **対象要件** | REQ-FUNC-013, 014, 015, 016, 017 |
| **目的** | 複数の絞込条件を組み合わせたAND条件での検索が正しく機能することを検証 |
| **前提条件** | ・ToDoが50件存在（各種ステータス、ラベル、日時分散）<br>・ラベルが10件存在 |
| **テスト手順** | **1. ラベル絞込（REQ-FUNC-013）**<br>&nbsp;&nbsp;1-1. 一覧画面でラベルフィルターから「仕事」ラベルを選択<br>&nbsp;&nbsp;1-2. 該当ToDoが表示されることを確認<br>&nbsp;&nbsp;1-3. ヒット件数を記録<br><br>**2. ステータス絞込追加（REQ-FUNC-015）**<br>&nbsp;&nbsp;2-1. ステータスフィルターから「着手中」を選択<br>&nbsp;&nbsp;2-2. ラベル「仕事」ANDステータス「着手中」で絞込されることを確認<br>&nbsp;&nbsp;2-3. ヒット件数が減少することを確認<br><br>**3. 日時範囲絞込追加（REQ-FUNC-014）**<br>&nbsp;&nbsp;3-1. 日付ピッカーで開始日を「2025-01-01」に設定<br>&nbsp;&nbsp;3-2. 終了日を「2025-01-31」に設定<br>&nbsp;&nbsp;3-3. 日時範囲内のToDoのみが表示されることを確認<br><br>**4. キーワード検索追加（REQ-FUNC-016）**<br>&nbsp;&nbsp;4-1. 検索ボックスに「計画書」と入力<br>&nbsp;&nbsp;4-2. すべての条件（ラベル+ステータス+日時+キーワード）のAND条件で絞込されることを確認<br>&nbsp;&nbsp;4-3. 検索結果のキーワードがハイライト表示されることを確認<br><br>**5. 条件の個別解除**<br>&nbsp;&nbsp;5-1. 適用中の条件が画面上に表示されることを確認<br>&nbsp;&nbsp;5-2. ラベル条件の「×」ボタンをクリック<br>&nbsp;&nbsp;5-3. ラベル条件のみが解除され、他の条件は維持されることを確認<br>&nbsp;&nbsp;5-4. ヒット件数が増加することを確認<br><br>**6. 全条件クリア**<br>&nbsp;&nbsp;6-1. 「条件をクリア」ボタンをクリック<br>&nbsp;&nbsp;6-2. すべての絞込条件が解除されることを確認<br>&nbsp;&nbsp;6-3. 全ToDoが表示されることを確認 |
| **期待結果** | ・各絞込条件が正しくAND条件で機能する<br>・条件追加のたびにヒット件数が適切に変化する<br>・適用中の条件が視覚的に明示される<br>・個別解除が正しく機能する<br>・全クリアで初期状態に戻る<br>・レスポンス時間が1.5秒以内（REQ-PERF-007）<br>・キーワードのハイライト表示が機能する |
| **確認ポイント** | ・複数フィルター条件のAND結合クエリが正しく生成されること<br>・SQLクエリのパフォーマンスが適切であること（複合インデックスの活用）<br>・UI/UXの使いやすさ（REQ-USE-004, 005） |
| **関連要件** | REQ-FUNC-013, 014, 015, 016, 017, REQ-PERF-007, REQ-USE-004, 005 |

#### TC-IT-031: キーワード検索の全文検索機能

| 項目 | 内容 |
|---|---|
| **対象要件** | REQ-FUNC-016, REQ-PERF-007, 008 |
| **目的** | 日本語全文検索が正しく機能し、性能要件を満たすことを検証 |
| **前提条件** | ・ToDoが10万件存在<br>・日本語全文検索インデックスが構築済み |
| **テスト手順** | **1. 単一キーワード検索**<br>&nbsp;&nbsp;1-1. 検索ボックスに「プロジェクト」と入力<br>&nbsp;&nbsp;1-2. タイトルまたは内容に「プロジェクト」を含むToDoが表示されることを確認<br>&nbsp;&nbsp;1-3. レスポンス時間を測定<br><br>**2. 複数キーワード検索**<br>&nbsp;&nbsp;2-1. 検索ボックスに「プロジェクト 計画書」と入力<br>&nbsp;&nbsp;2-2. 両方のキーワードを含むToDoが表示されることを確認<br><br>**3. 部分一致検索**<br>&nbsp;&nbsp;3-1. 検索ボックスに「プロジェ」と入力<br>&nbsp;&nbsp;3-2. 「プロジェクト」を含むToDoが表示されることを確認<br><br>**4. 大文字小文字を区別しない検索**<br>&nbsp;&nbsp;4-1. 検索ボックスに「PROJECT」と入力<br>&nbsp;&nbsp;4-2. 「project」や「Project」を含むToDoも表示されることを確認<br><br>**5. 日本語形態素解析**<br>&nbsp;&nbsp;5-1. 検索ボックスに「書く」と入力<br>&nbsp;&nbsp;5-2. 「書いた」「書きました」などの活用形も検索されることを確認<br><br>**6. 100万件データでの性能検証（REQ-PERF-008）**<br>&nbsp;&nbsp;6-1. データベースに100万件のToDoを投入<br>&nbsp;&nbsp;6-2. 全文検索を実行<br>&nbsp;&nbsp;6-3. レスポンス時間が2秒以内であることを確認 |
| **期待結果** | **1～5. 基本検索:**<br>・正しいヒットが得られる<br>・レスポンス時間が1秒以内（REQ-PERF-007: 10万件以下）<br><br>**6. 大規模検索:**<br>・レスポンス時間が2秒以内（REQ-PERF-008: 100万件）<br>・検索結果の精度が高い（日本語ワードブレーカーが機能） |
| **確認ポイント** | ・SQL Serverのフルテキスト検索が正しく構成されていること<br>・日本語ワードブレーカー（LANGUAGE 1041）が機能すること<br>・インデックスが適切に使用されていること<br>・大規模データでも性能要件を満たすこと |
| **関連要件** | REQ-FUNC-016, REQ-PERF-007, 008 |


---

## 4. データ整合性テスト

### 4.1 トランザクション整合性テスト

#### TC-IT-100: ToDo作成時のトランザクション整合性

| 項目 | 内容 |
|---|---|
| **対象要件** | REQ-FUNC-001, 012, REQ-REL-002 |
| **目的** | ToDoとラベルの紐付けが1つのトランザクションで正しく処理されることを検証 |
| **前提条件** | ・ラベルが5件存在<br>・データベースが正常稼働中 |
| **テスト手順** | **1. 正常系：トランザクションコミット**<br>&nbsp;&nbsp;1-1. ToDoを作成し、3つのラベルを選択<br>&nbsp;&nbsp;1-2. 「保存」をクリック<br>&nbsp;&nbsp;1-3. データベースを直接確認し、Todoテーブルに1レコード、TodoLabelテーブルに3レコード追加されていることを確認<br><br>**2. 異常系：トランザクションロールバック**<br>&nbsp;&nbsp;2-1. ToDoを作成し、存在しないLabelID（9999）を含むラベルリストを設定（開発者ツールで改ざん）<br>&nbsp;&nbsp;2-2. 「保存」をクリック<br>&nbsp;&nbsp;2-3. エラーが返されることを確認<br>&nbsp;&nbsp;2-4. データベースを直接確認し、Todoテーブルにレコードが追加されていないことを確認（ロールバック確認）<br>&nbsp;&nbsp;2-5. TodoLabelテーブルにもレコードが追加されていないことを確認 |
| **期待結果** | **1. 正常系:**<br>・TodoとTodoLabelがアトミックに保存される<br>・外部キー制約が満たされる<br><br>**2. 異常系:**<br>・400 Bad Request / 404 Not Found<br>・Todoレコードが保存されない（ロールバック）<br>・TodoLabelレコードも保存されない<br>・データ不整合が発生しない |
| **確認ポイント** | ・Entity Framework CoreのトランザクションスコープがSaveChanges()で機能すること<br>・外部キー制約違反時に適切にロールバックされること<br>・REQ-REL-002（データ損失ゼロ）を満たすこと |
| **関連要件** | REQ-FUNC-001, 012, REQ-REL-002, REQ-DATA-001 |

#### TC-IT-101: 同時更新の競合検出（楽観的ロック）

| 項目 | 内容 |
|---|---|
| **対象要件** | REQ-FUNC-004, REQ-REL-002 |
| **目的** | 同時更新時の競合が検出され、データ整合性が保たれることを検証 |
| **前提条件** | ToDoが1件存在 |
| **テスト手順** | **1. 同時更新シナリオ**<br>&nbsp;&nbsp;1-1. ブラウザA、Bで同じToDoの詳細画面を開く<br>&nbsp;&nbsp;1-2. ブラウザAでタイトルを「更新A」に変更して「保存」<br>&nbsp;&nbsp;1-3. 成功することを確認<br>&nbsp;&nbsp;1-4. ブラウザBでタイトルを「更新B」に変更して「保存」<br>&nbsp;&nbsp;1-5. 競合エラーが表示されることを確認<br><br>**2. 競合後の再試行**<br>&nbsp;&nbsp;2-1. ブラウザBで「再読み込み」ボタンをクリック<br>&nbsp;&nbsp;2-2. 最新データ（ブラウザAの更新内容）が表示されることを確認<br>&nbsp;&nbsp;2-3. 再度編集して保存し、成功することを確認 |
| **期待結果** | ・ブラウザAの更新は成功（200 OK）<br>・ブラウザBの更新は競合エラー（409 Conflict）<br>・エラーメッセージ: 「他のユーザーにより更新されています。再読み込みしてください」<br>・データベース上のデータがブラウザAの更新内容で保持される<br>・ブラウザBの更新内容は反映されない（データ整合性保護） |
| **確認ポイント** | ・Entity Framework CoreのConcurrency Token（UpdatedAtまたはRowVersion）が機能すること<br>・DbUpdateConcurrencyExceptionが適切にハンドリングされること<br>・ユーザーへの適切なフィードバックがあること |
| **関連要件** | REQ-FUNC-004, REQ-REL-002, REQ-USE-005 |

### 4.2 外部キー制約テスト

#### TC-IT-110: ラベル削除時のカスケード動作

| 項目 | 内容 |
|---|---|
| **対象要件** | REQ-FUNC-011 |
| **目的** | ラベル削除時に中間テーブル（TodoLabel）の紐付けが正しくカスケード削除されることを検証 |
| **前提条件** | ・ラベル「テスト用」が存在<br>・10件のToDoに「テスト用」ラベルが設定されている |
| **テスト手順** | 1. ラベル管理画面で「テスト用」ラベルを削除<br>2. 使用中の警告が表示されることを確認<br>3. 削除を実行<br>4. データベースを直接確認し、Labelテーブルから削除されていることを確認<br>5. TodoLabelテーブルから該当ラベルの紐付けが削除されていることを確認（10レコード削除）<br>6. Todoテーブルのレコードは削除されていないことを確認<br>7. ToDoの詳細画面を開き、「テスト用」ラベルが表示されないことを確認 |
| **期待結果** | ・ラベル削除に成功（200 OK / 204 No Content）<br>・Labelテーブルから削除される<br>・TodoLabelテーブルから紐付けが削除される（ON DELETE CASCADE）<br>・Todoレコードは保持される<br>・UI上でもラベルが除去される |
| **確認ポイント** | ・外部キー制約のON DELETE CASCADEが機能すること<br>・参照整合性が保たれること<br>・孤立レコードが発生しないこと |
| **関連要件** | REQ-FUNC-011, REQ-DATA-002 |

### 4.3 論理削除の整合性テスト

#### TC-IT-120: 論理削除されたToDoのフィルタリング

| 項目 | 内容 |
|---|---|
| **対象要件** | REQ-FUNC-005, REQ-REL-002 |
| **目的** | 論理削除されたToDoが一覧や検索結果に表示されないことを検証 |
| **前提条件** | ・ToDoが20件存在<br>・うち5件が論理削除済み（IsDeleted=1） |
| **テスト手順** | **1. 一覧表示での除外**<br>&nbsp;&nbsp;1-1. 一覧画面を表示<br>&nbsp;&nbsp;1-2. 論理削除されていないToDoのみが表示されることを確認（15件）<br>&nbsp;&nbsp;1-3. データベースを直接確認し、論理削除済みの5件が存在することを確認<br><br>**2. 検索での除外**<br>&nbsp;&nbsp;2-1. すべてのToDoに共通するキーワードで検索<br>&nbsp;&nbsp;2-2. 論理削除されていないToDoのみがヒットすることを確認<br><br>**3. 直接アクセスでの404エラー**<br>&nbsp;&nbsp;3-1. 論理削除済みToDoのIDを取得<br>&nbsp;&nbsp;3-2. そのIDで詳細画面にアクセス<br>&nbsp;&nbsp;3-3. 404 Not Foundエラーが返されることを確認<br><br>**4. API直接呼び出しでの除外**<br>&nbsp;&nbsp;4-1. ブラウザ開発者ツールまたはPostmanでGET /api/v1/todosを実行<br>&nbsp;&nbsp;4-2. レスポンスに論理削除されたToDoが含まれないことを確認<br>&nbsp;&nbsp;4-3. totalカウントが15であることを確認 |
| **期待結果** | ・一覧、検索、詳細のすべてで論理削除されたToDoが除外される<br>・Entity Framework CoreのQueryFilter（HasQueryFilter(t => !t.IsDeleted)）が機能する<br>・UI上では削除されたように見える<br>・データベース上ではIsDeleted=1で保持される（物理削除されない） |
| **確認ポイント** | ・グローバルクエリフィルターが全クエリに適用されること<br>・データ損失ゼロ要件（REQ-REL-002）を満たすこと<br>・復元が可能な状態でデータが保持されること |
| **関連要件** | REQ-FUNC-005, REQ-REL-002 |

---

## 5. 非機能要件テスト

### 5.1 性能テスト

#### TC-IT-200: API応答時間検証（単一ToDo操作）

| 項目 | 内容 |
|---|---|
| **対象要件** | REQ-PERF-001 |
| **目的** | 単一ToDoのCRUD操作が500ms以内で応答することを検証 |
| **前提条件** | ・データベースに1万件のToDoが存在<br>・同時接続数10ユーザーでの負荷テスト環境 |
| **テスト手順** | **1. POST /api/v1/todos（作成）**<br>&nbsp;&nbsp;1-1. 10ユーザーが同時にToDo作成リクエストを送信<br>&nbsp;&nbsp;1-2. 各リクエストの応答時間を測定<br>&nbsp;&nbsp;1-3. 95パーセンタイルを計算<br><br>**2. GET /api/v1/todos/{id}（詳細取得）**<br>&nbsp;&nbsp;2-1. 10ユーザーが同時に異なるToDoの詳細取得リクエストを送信<br>&nbsp;&nbsp;2-2. 各リクエストの応答時間を測定<br>&nbsp;&nbsp;2-3. 95パーセンタイルを計算<br><br>**3. PUT /api/v1/todos/{id}（更新）**<br>&nbsp;&nbsp;3-1. 10ユーザーが同時にToDo更新リクエストを送信<br>&nbsp;&nbsp;3-2. 各リクエストの応答時間を測定<br>&nbsp;&nbsp;3-3. 95パーセンタイルを計算<br><br>**4. DELETE /api/v1/todos/{id}（削除）**<br>&nbsp;&nbsp;4-1. 10ユーザーが同時にToDo削除リクエストを送信<br>&nbsp;&nbsp;4-2. 各リクエストの応答時間を測定<br>&nbsp;&nbsp;4-3. 95パーセンタイルを計算 |
| **期待結果** | ・POST: 95パーセンタイル ≤ 500ms<br>・GET: 95パーセンタイル ≤ 300ms（詳細取得は500ms以内の目標だがより速い）<br>・PUT: 95パーセンタイル ≤ 500ms<br>・DELETE: 95パーセンタイル ≤ 300ms<br>・すべてのリクエストが成功（200/201/204）<br>・エラー率 < 1% |
| **確認ポイント** | ・データベースインデックスが効果的に使用されていること<br>・N+1問題が発生していないこと<br>・Entity Framework CoreのEager LoadingまたはExplicit Loadingが適切に使用されていること |
| **測定方法** | ・負荷テストツール: Apache JMeter、k6、Azure Load Testing<br>・Application Insights等のAPMツールでの監視 |
| **関連要件** | REQ-PERF-001 |

#### TC-IT-201: API応答時間検証（一覧取得）

| 項目 | 内容 |
|---|---|
| **対象要件** | REQ-PERF-002 |
| **目的** | ToDo一覧取得が1秒以内で応答することを検証 |
| **前提条件** | ・データベースに1万件のToDoが存在<br>・同時接続数10ユーザー |
| **テスト手順** | **1. 基本一覧取得（ページネーション）**<br>&nbsp;&nbsp;1-1. 10ユーザーが同時にGET /api/v1/todos?page=1&pageSize=20を実行<br>&nbsp;&nbsp;1-2. 応答時間を測定<br><br>**2. フィルター付き一覧取得**<br>&nbsp;&nbsp;2-1. ステータスフィルター: GET /api/v1/todos?statuses=InProgress<br>&nbsp;&nbsp;2-2. 応答時間を測定<br><br>**3. 複合フィルター一覧取得**<br>&nbsp;&nbsp;3-1. GET /api/v1/todos?statuses=InProgress&labelIds=1,2&startDate=2025-01-01<br>&nbsp;&nbsp;3-2. 応答時間を測定<br><br>**4. ページング複数ページ取得**<br>&nbsp;&nbsp;4-1. pageSize=100で一覧取得<br>&nbsp;&nbsp;4-2. 応答時間を測定 |
| **期待結果** | ・すべてのパターンで95パーセンタイル ≤ 1秒<br>・基本一覧取得: 500ms以内（より速い目標）<br>・複合フィルター: 1秒以内<br>・ページング処理が効率的<br>・OFFSET-FETCHまたはシーク法によるページネーション |
| **確認ポイント** | ・複合インデックス（IX_Todo_Status_CreatedAt等）が使用されていること<br>・SELECT文にLIMIT/OFFSET（またはSQL ServerのOFFSET-FETCH）が含まれること<br>・不要なカラムがSELECTされていないこと（N+1問題回避） |
| **関連要件** | REQ-PERF-002, REQ-FUNC-002 |

#### TC-IT-202: 画面初期表示時間検証

| 項目 | 内容 |
|---|---|
| **対象要件** | REQ-PERF-003 |
| **目的** | フロントエンド初期表示が2秒以内で完了することを検証 |
| **前提条件** | ・通常ネットワーク環境（10Mbps）<br>・データベースに20件のToDoが存在<br>・初回アクセス（キャッシュなし） |
| **テスト手順** | **1. パフォーマンス測定**<br>&nbsp;&nbsp;1-1. ブラウザをシークレットモードで起動（キャッシュクリア）<br>&nbsp;&nbsp;1-2. Chrome DevToolsのPerformanceタブを開く<br>&nbsp;&nbsp;1-3. アプリケーションのURLにアクセス<br>&nbsp;&nbsp;1-4. First Contentful Paint (FCP)を測定<br>&nbsp;&nbsp;1-5. Largest Contentful Paint (LCP)を測定<br>&nbsp;&nbsp;1-6. Time to Interactive (TTI)を測定<br><br>**2. Lighthouseによる自動測定**<br>&nbsp;&nbsp;2-1. Chrome DevToolsのLighthouseタブを開く<br>&nbsp;&nbsp;2-2. パフォーマンス監査を実行<br>&nbsp;&nbsp;2-3. スコアを確認 |
| **期待結果** | ・LCP ≤ 2秒（REQ-PERF-003）<br>・FCP ≤ 1秒<br>・TTI ≤ 2.5秒<br>・Lighthouseパフォーマンススコア ≥ 90<br>・JavaScriptバンドルサイズが適切（Tree Shakingが機能）<br>・Lazy Loadingが機能している |
| **確認ポイント** | ・Angular Production Buildが使用されていること<br>・Ahead-of-Time (AOT) コンパイルが有効<br>・Code Splittingが適用されていること<br>・画像等のアセットが最適化されていること |
| **測定方法** | ・Chrome DevTools Performance<br>・Lighthouse<br>・WebPageTest |
| **関連要件** | REQ-PERF-003, REQ-USE-001 |

#### TC-IT-203: 同時接続ユーザー数検証

| 項目 | 内容 |
|---|---|
| **対象要件** | REQ-PERF-005 |
| **目的** | 100ユーザー同時接続時もレスポンスタイム劣化が20%以内であることを検証 |
| **前提条件** | ・データベースに1万件のToDo<br>・負荷テスト環境 |
| **テスト手順** | **1. ベースライン測定（10ユーザー）**<br>&nbsp;&nbsp;1-1. 10ユーザーで一覧取得のベースライン応答時間を測定<br>&nbsp;&nbsp;1-2. 平均値、95パーセンタイルを記録<br><br>**2. 負荷テスト（100ユーザー）**<br>&nbsp;&nbsp;2-1. 100ユーザーに増やして同じテストを実行<br>&nbsp;&nbsp;2-2. 平均値、95パーセンタイルを測定<br>&nbsp;&nbsp;2-3. ベースラインとの劣化率を計算<br><br>**3. スパイクテスト**<br>&nbsp;&nbsp;3-1. 10ユーザー→100ユーザーへ急増<br>&nbsp;&nbsp;3-2. システムが安定するまでの時間を測定<br>&nbsp;&nbsp;3-3. エラー率を確認 |
| **期待結果** | ・100ユーザー時の95パーセンタイル ≤ ベースライン × 1.2（劣化20%以内）<br>・エラー率 < 1%<br>・スパイク時もシステムが安定<br>・タイムアウトが発生しない |
| **確認ポイント** | ・ASP.NET CoreのKestrelの設定が適切（MaxConcurrentConnections等）<br>・データベース接続プールが適切に設定されていること<br>・メモリリークが発生していないこと |
| **測定方法** | ・Apache JMeter<br>・k6<br>・Azure Load Testing |
| **関連要件** | REQ-PERF-005 |

#### TC-IT-204: 大規模データ検索性能検証

| 項目 | 内容 |
|---|---|
| **対象要件** | REQ-PERF-006, 008 |
| **目的** | 100万レコード存在時でも検索が2秒以内で完了することを検証 |
| **前提条件** | ・データベースに100万件のToDoが存在<br>・フルテキストインデックスが構築済み |
| **テスト手順** | **1. データ投入**<br>&nbsp;&nbsp;1-1. テストデータジェネレーターで100万件のToDoを投入<br>&nbsp;&nbsp;1-2. フルテキストインデックスの更新を待機<br><br>**2. 全文検索テスト**<br>&nbsp;&nbsp;2-1. キーワード検索APIを実行: GET /api/v1/todos?keyword=プロジェクト<br>&nbsp;&nbsp;2-2. 応答時間を測定<br>&nbsp;&nbsp;2-3. 検索結果の正確性を確認<br><br>**3. 複合絞込+全文検索**<br>&nbsp;&nbsp;3-1. ステータス+ラベル+キーワードの複合条件で検索<br>&nbsp;&nbsp;3-2. 応答時間を測定<br><br>**4. インデックス使用確認**<br>&nbsp;&nbsp;4-1. SQL Server Management Studio (SSMS)で実行計画を確認<br>&nbsp;&nbsp;4-2. フルテキストインデックスが使用されていることを確認<br>&nbsp;&nbsp;4-3. Index Seekが使用されていることを確認（Table Scanでないこと） |
| **期待結果** | ・全文検索: 95パーセンタイル ≤ 2秒（REQ-PERF-008）<br>・複合絞込+全文検索: ≤ 2.5秒<br>・検索結果の精度が高い<br>・インデックスが効果的に使用されている<br>・性能劣化が20%以内（REQ-PERF-006） |
| **確認ポイント** | ・SQL ServerのFull-Text Searchが正しく構成されていること<br>・日本語ワードブレーカー（LANGUAGE 1041）が使用されていること<br>・複合インデックスが適切に設計されていること<br>・CONTAINS句またはFREETEXT句が使用されていること |
| **関連要件** | REQ-PERF-006, 008, REQ-FUNC-016 |


### 5.2 セキュリティテスト

#### TC-IT-300: SQLインジェクション対策検証

| 項目 | 内容 |
|---|---|
| **対象要件** | REQ-SEC-001 |
| **目的** | SQLインジェクション攻撃が防御されることを検証 |
| **前提条件** | アプリケーションが稼働中 |
| **テスト手順** | **1. 検索キーワードでのSQLインジェクション試行**<br>&nbsp;&nbsp;1-1. 検索ボックスに以下を入力:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`' OR '1'='1`<br>&nbsp;&nbsp;1-2. 検索を実行<br>&nbsp;&nbsp;1-3. 全データが返されないことを確認<br>&nbsp;&nbsp;1-4. エラーが発生しないことを確認<br><br>**2. タイトルフィールドでのSQLインジェクション試行**<br>&nbsp;&nbsp;2-1. ToDo作成時のタイトルに以下を入力:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`'; DROP TABLE Todo; --`<br>&nbsp;&nbsp;2-2. 保存を実行<br>&nbsp;&nbsp;2-3. 通常の文字列として保存されることを確認<br>&nbsp;&nbsp;2-4. データベースのTodoテーブルが削除されていないことを確認<br><br>**3. ステータスフィルターでのSQLインジェクション試行**<br>&nbsp;&nbsp;3-1. ブラウザ開発者ツールでstatusesパラメータを改ざん:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`statuses=InProgress' OR '1'='1`<br>&nbsp;&nbsp;3-2. APIリクエストを送信<br>&nbsp;&nbsp;3-3. エラーまたは正常な空結果が返されることを確認<br><br>**4. パラメータ化クエリ確認**<br>&nbsp;&nbsp;4-1. SQL Profilerでクエリをキャプチャ<br>&nbsp;&nbsp;4-2. パラメータ化クエリ（@p0, @p1等）が使用されていることを確認<br>&nbsp;&nbsp;4-3. 生SQLの連結が使用されていないことを確認 |
| **期待結果** | ・すべてのSQLインジェクション試行が無効化される<br>・攻撃文字列が通常のテキストとして扱われる<br>・データベースが破壊されない<br>・機密情報が漏洩しない<br>・Entity Framework Coreのパラメータ化クエリが使用される<br>・エラーメッセージにSQL構文が含まれない |
| **確認ポイント** | ・Entity Framework CoreのLINQクエリが使用されていること<br>・FromSqlRawを使用する場合はパラメータ化されていること<br>・ユーザー入力が直接SQLに連結されていないこと |
| **関連要件** | REQ-SEC-001 |

#### TC-IT-301: XSS（クロスサイトスクリプティング）対策検証

| 項目 | 内容 |
|---|---|
| **対象要件** | REQ-SEC-002 |
| **目的** | XSS攻撃が防御されることを検証 |
| **前提条件** | アプリケーションが稼働中 |
| **テスト手順** | **1. タイトルでのXSS試行**<br>&nbsp;&nbsp;1-1. ToDo作成時のタイトルに以下を入力:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`<script>alert('XSS')</script>`<br>&nbsp;&nbsp;1-2. 保存を実行<br>&nbsp;&nbsp;1-3. 一覧画面および詳細画面を表示<br>&nbsp;&nbsp;1-4. アラートが表示されないことを確認<br>&nbsp;&nbsp;1-5. ブラウザ開発者ツールでHTMLを確認し、エスケープされていることを確認:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`&lt;script&gt;alert('XSS')&lt;/script&gt;`<br><br>**2. 内容でのXSS試行**<br>&nbsp;&nbsp;2-1. 内容フィールドに以下を入力:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`<img src=x onerror="alert('XSS')">`<br>&nbsp;&nbsp;2-2. 保存して詳細画面を表示<br>&nbsp;&nbsp;2-3. アラートが表示されないことを確認<br><br>**3. ラベル名でのXSS試行**<br>&nbsp;&nbsp;3-1. ラベル名に以下を入力:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`<svg onload="alert('XSS')">`<br>&nbsp;&nbsp;3-2. 保存を実行<br>&nbsp;&nbsp;3-3. ラベル一覧およびToDo詳細画面でラベルを表示<br>&nbsp;&nbsp;3-4. アラートが表示されないことを確認<br><br>**4. DOMベースXSS試行**<br>&nbsp;&nbsp;4-1. URLパラメータに攻撃文字列を含める:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`?keyword=<script>alert('XSS')</script>`<br>&nbsp;&nbsp;4-2. 画面を表示<br>&nbsp;&nbsp;4-3. アラートが表示されないことを確認 |
| **期待結果** | ・すべてのXSS試行が無効化される<br>・スクリプトが実行されない<br>・Angularの自動エスケープが機能する<br>・innerHTML使用箇所がない（またはDomSanitizerでサニタイズされている）<br>・攻撃文字列がエスケープされてテキストとして表示される |
| **確認ポイント** | ・Angularのテンプレートバインディング（{{ }}）が使用されていること<br>・innerHTMLが使用されていないこと<br>・DomSanitizerが適切に使用されていること<br>・Content Security Policy (CSP) ヘッダーが設定されていること（推奨） |
| **関連要件** | REQ-SEC-002 |

#### TC-IT-302: CSRF（クロスサイトリクエストフォージェリ）対策検証

| 項目 | 内容 |
|---|---|
| **対象要件** | REQ-SEC-003 |
| **目的** | CSRF攻撃が防御されることを検証 |
| **前提条件** | ・アプリケーションにログイン済み（将来的な認証機能対応時）<br>・現フェーズでは基本的なCSRF対策の実装確認 |
| **テスト手順** | **1. Anti-Forgery Token確認（将来機能）**<br>&nbsp;&nbsp;1-1. フォームのHTMLを確認<br>&nbsp;&nbsp;1-2. Anti-Forgeryトークンが含まれていることを確認<br>&nbsp;&nbsp;1-3. ブラウザ開発者ツールでトークンを削除<br>&nbsp;&nbsp;1-4. フォーム送信を試行<br>&nbsp;&nbsp;1-5. 400 Bad Requestが返されることを確認<br><br>**2. SameSite Cookie確認**<br>&nbsp;&nbsp;2-1. ブラウザ開発者ツールのApplicationタブを開く<br>&nbsp;&nbsp;2-2. Cookieを確認<br>&nbsp;&nbsp;2-3. SameSite属性がStrictまたはLaxに設定されていることを確認<br><br>**3. 外部サイトからのリクエスト試行**<br>&nbsp;&nbsp;3-1. 別のドメインのHTMLページを作成:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;```html<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<form action="https://todo-app.com/api/v1/todos" method="POST"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  <input name="title" value="CSRF Attack"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</form><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;```<br>&nbsp;&nbsp;3-2. フォームを自動送信<br>&nbsp;&nbsp;3-3. リクエストが拒否されることを確認<br><br>**4. CORS設定確認**<br>&nbsp;&nbsp;4-1. 外部ドメインからAPIを呼び出し<br>&nbsp;&nbsp;4-2. CORSエラーが発生することを確認<br>&nbsp;&nbsp;4-3. 許可されたオリジンのみアクセス可能であることを確認 |
| **期待結果** | ・Anti-Forgery Token（将来実装）が検証される<br>・SameSite=Strict/Lax Cookieが設定される<br>・外部サイトからのリクエストが拒否される<br>・CORSが適切に設定されている<br>・Refererヘッダーのチェックが機能する（ASP.NET Core標準） |
| **確認ポイント** | ・ASP.NET CoreのValidateAntiForgeryToken（将来実装）<br>・Cookie設定にSameSite属性が含まれること<br>・CORSミドルウェアが適切に設定されていること<br>・許可オリジンのホワイトリストが管理されていること |
| **関連要件** | REQ-SEC-003 |

#### TC-IT-303: HTTPS通信検証

| 項目 | 内容 |
|---|---|
| **対象要件** | REQ-SEC-004 |
| **目的** | すべての通信がHTTPSで暗号化されることを検証 |
| **前提条件** | HTTPS証明書が設定済み |
| **テスト手順** | **1. HTTPSアクセス**<br>&nbsp;&nbsp;1-1. https://でアプリケーションにアクセス<br>&nbsp;&nbsp;1-2. 正常にアクセスできることを確認<br>&nbsp;&nbsp;1-3. ブラウザのアドレスバーに鍵アイコンが表示されることを確認<br><br>**2. HTTPリダイレクト**<br>&nbsp;&nbsp;2-1. http://でアプリケーションにアクセス<br>&nbsp;&nbsp;2-2. 自動的にhttps://にリダイレクトされることを確認<br>&nbsp;&nbsp;2-3. レスポンスヘッダーに301/302リダイレクトが含まれることを確認<br><br>**3. HSTSヘッダー確認**<br>&nbsp;&nbsp;3-1. ブラウザ開発者ツールのNetworkタブを開く<br>&nbsp;&nbsp;3-2. レスポンスヘッダーを確認<br>&nbsp;&nbsp;3-3. Strict-Transport-Securityヘッダーが含まれることを確認:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`Strict-Transport-Security: max-age=31536000`<br><br>**4. 混在コンテンツチェック**<br>&nbsp;&nbsp;4-1. ブラウザコンソールを確認<br>&nbsp;&nbsp;4-2. Mixed Content警告が表示されないことを確認<br>&nbsp;&nbsp;4-3. すべてのリソース（画像、CSS、JS）がHTTPSで読み込まれることを確認<br><br>**5. API通信の暗号化**<br>&nbsp;&nbsp;5-1. ブラウザ開発者ツールでAPIリクエストを確認<br>&nbsp;&nbsp;5-2. すべてのAPIエンドポイントがhttps://でアクセスされることを確認<br>&nbsp;&nbsp;5-3. TLS 1.2以上が使用されていることを確認 |
| **期待結果** | ・HTTPSアクセスが正常に機能<br>・HTTPからHTTPSへの自動リダイレクト<br>・HSTSヘッダーが設定されている（max-age=31536000）<br>・混在コンテンツが存在しない<br>・すべてのAPI通信が暗号化されている<br>・TLS 1.2以上が使用される |
| **確認ポイント** | ・ASP.NET CoreのUseHttpsRedirection()が設定されていること<br>・HSTSミドルウェアが設定されていること<br>・SSL証明書が有効であること<br>・弱い暗号化スイートが無効化されていること |
| **関連要件** | REQ-SEC-004 |

#### TC-IT-304: 入力値検証（バリデーション）統合テスト

| 項目 | 内容 |
|---|---|
| **対象要件** | REQ-SEC-005 |
| **目的** | サーバー側での厳密なバリデーションが機能することを検証 |
| **前提条件** | アプリケーションが稼働中 |
| **テスト手順** | **1. クライアント側バリデーションのバイパス**<br>&nbsp;&nbsp;1-1. ブラウザ開発者ツールでHTMLのrequired属性を削除<br>&nbsp;&nbsp;1-2. タイトル空欄でToDo作成を試行<br>&nbsp;&nbsp;1-3. サーバー側で400エラーが返されることを確認<br><br>**2. データ型の検証**<br>&nbsp;&nbsp;2-1. ToDoIDに文字列を設定してAPIを直接呼び出し:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`GET /api/v1/todos/abc`<br>&nbsp;&nbsp;2-2. 400 Bad Requestが返されることを確認<br><br>**3. 範囲の検証**<br>&nbsp;&nbsp;3-1. pageSizeに101を設定（最大100を超過）<br>&nbsp;&nbsp;3-2. 400 Bad Requestが返されることを確認<br>&nbsp;&nbsp;3-3. エラーメッセージ: "pageSize must be between 1 and 100"<br><br>**4. 列挙型の検証**<br>&nbsp;&nbsp;4-1. statusに無効な値を設定:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`{"status": "InvalidStatus"}`<br>&nbsp;&nbsp;4-2. 400 Bad Requestが返されることを確認<br><br>**5. ネストされたオブジェクトの検証**<br>&nbsp;&nbsp;5-1. labelIdsに存在しないIDを設定<br>&nbsp;&nbsp;5-2. 404 Not Foundまたは400 Bad Requestが返されることを確認<br><br>**6. FluentValidation動作確認**<br>&nbsp;&nbsp;6-1. 複数のバリデーションエラーを同時に発生させる<br>&nbsp;&nbsp;6-2. すべてのエラーがレスポンスに含まれることを確認<br>&nbsp;&nbsp;6-3. エラーメッセージが具体的で理解しやすいことを確認 |
| **期待結果** | ・クライアント側バリデーションをバイパスしてもサーバー側で拒否される<br>・すべての入力値が厳密に検証される<br>・データ型、範囲、フォーマットが正しくチェックされる<br>・FluentValidationが機能する<br>・エラーメッセージが具体的で理解しやすい（REQ-USE-005） |
| **確認ポイント** | ・DataAnnotationsまたはFluentValidationが実装されていること<br>・ModelState.IsValidのチェックが実装されていること<br>・すべてのAPIエンドポイントでバリデーションが実行されること<br>・クライアント側検証は補助的な位置づけであること |
| **関連要件** | REQ-SEC-005, REQ-USE-005, REQ-USE-006 |

#### TC-IT-305: APIレート制限検証

| 項目 | 内容 |
|---|---|
| **対象要件** | REQ-SEC-006 |
| **目的** | APIレート制限が機能し、DoS攻撃を防御することを検証 |
| **前提条件** | AspNetCoreRateLimitが設定済み（IP単位で1分間に100リクエスト） |
| **テスト手順** | **1. 通常のリクエスト**<br>&nbsp;&nbsp;1-1. 1分間に50リクエストを送信<br>&nbsp;&nbsp;1-2. すべて正常に応答されることを確認<br><br>**2. レート制限超過**<br>&nbsp;&nbsp;2-1. 1分間に101リクエストを連続送信<br>&nbsp;&nbsp;2-2. 101番目のリクエストが429 Too Many Requestsで拒否されることを確認<br>&nbsp;&nbsp;2-3. レスポンスヘッダーを確認:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`Retry-After: 60`<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`X-Rate-Limit-Limit: 100`<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`X-Rate-Limit-Remaining: 0`<br><br>**3. レート制限リセット**<br>&nbsp;&nbsp;3-1. 1分待機<br>&nbsp;&nbsp;3-2. 再度リクエストを送信<br>&nbsp;&nbsp;3-3. 正常に応答されることを確認<br><br>**4. 異なるIPからのアクセス**<br>&nbsp;&nbsp;4-1. IPアドレスAから100リクエスト送信<br>&nbsp;&nbsp;4-2. IPアドレスBから100リクエスト送信<br>&nbsp;&nbsp;4-3. 両方とも成功することを確認（IP単位での制限） |
| **期待結果** | ・1分間に100リクエストまで許可される<br>・101番目のリクエストは429エラー<br>・エラーメッセージ: "API rate limit exceeded"<br>・Retry-Afterヘッダーが含まれる<br>・1分後に制限がリセットされる<br>・IP単位で独立して制限される |
| **確認ポイント** | ・AspNetCoreRateLimitミドルウェアが設定されていること<br>・appsettings.jsonにレート制限設定が含まれること<br>・429エラーが適切に返されること<br>・ユーザーフレンドリーなエラーメッセージが表示されること |
| **測定方法** | ・Apache JMeter<br>・k6<br>・curl/Postmanでの手動テスト |
| **関連要件** | REQ-SEC-006 |

### 5.3 ユーザビリティテスト

#### TC-IT-400: レスポンシブデザイン検証

| 項目 | 内容 |
|---|---|
| **対象要件** | REQ-USE-001 |
| **目的** | 各デバイスで正しくレイアウトが表示されることを検証 |
| **前提条件** | アプリケーションが稼働中 |
| **テスト手順** | **1. デスクトップ（1920x1080）**<br>&nbsp;&nbsp;1-1. ブラウザを1920x1080にリサイズ<br>&nbsp;&nbsp;1-2. ToDo一覧、詳細、作成画面を表示<br>&nbsp;&nbsp;1-3. レイアウト崩れがないことを確認<br>&nbsp;&nbsp;1-4. すべての要素が適切に配置されていることを確認<br><br>**2. タブレット（768x1024）**<br>&nbsp;&nbsp;2-1. ブラウザを768x1024にリサイズ（またはiPadエミュレーション）<br>&nbsp;&nbsp;2-2. レイアウトがタブレット向けに調整されることを確認<br>&nbsp;&nbsp;2-3. メニューがハンバーガーメニューに変わることを確認<br>&nbsp;&nbsp;2-4. タッチ操作を想定した十分なタップ領域があることを確認<br><br>**3. スマートフォン（375x667）**<br>&nbsp;&nbsp;3-1. ブラウザを375x667にリサイズ（またはiPhone SEエミュレーション）<br>&nbsp;&nbsp;3-2. レイアウトが縦向きスマートフォンに最適化されることを確認<br>&nbsp;&nbsp;3-3. 横スクロールが発生しないことを確認<br>&nbsp;&nbsp;3-4. フォントサイズが読みやすいことを確認<br><br>**4. 最小解像度（320x568）**<br>&nbsp;&nbsp;4-1. ブラウザを320x568にリサイズ<br>&nbsp;&nbsp;4-2. レイアウト崩れがないことを確認<br>&nbsp;&nbsp;4-3. すべての機能が使用可能であることを確認<br><br>**5. 4K解像度（3840x2160）**<br>&nbsp;&nbsp;5-1. ブラウザを最大化または4Kディスプレイで表示<br>&nbsp;&nbsp;5-2. コンテンツが適切にスケールされることを確認<br>&nbsp;&nbsp;5-3. 画像やアイコンがぼやけていないことを確認<br><br>**6. 画面回転（スマートフォン）**<br>&nbsp;&nbsp;6-1. 縦向きから横向きに回転<br>&nbsp;&nbsp;6-2. レイアウトが自動調整されることを確認<br>&nbsp;&nbsp;6-3. 横向きでも使いやすいことを確認 |
| **期待結果** | ・すべての解像度でレイアウト崩れが発生しない<br>・320px～4K解像度まで対応<br>・レスポンシブブレークポイントが適切に設定されている<br>・モバイルでタップ領域が十分（最小44x44px）<br>・横スクロールが発生しない<br>・コンテンツが読みやすい |
| **確認ポイント** | ・Angular Material Layoutが適切に使用されていること<br>・CSSメディアクエリが設定されていること<br>・Flexbox/CSS Gridが使用されていること<br>・ビューポートメタタグが設定されていること:<br>&nbsp;&nbsp;`<meta name="viewport" content="width=device-width, initial-scale=1">` |
| **テスト環境** | ・Chrome DevTools Device Mode<br>・実機（iPhone、iPad、Android）<br>・BrowserStack（複数デバイス同時テスト） |
| **関連要件** | REQ-USE-001, 003 |

#### TC-IT-401: ブラウザ互換性検証

| 項目 | 内容 |
|---|---|
| **対象要件** | REQ-USE-002 |
| **目的** | 主要ブラウザで正しく動作することを検証 |
| **前提条件** | 各ブラウザがインストール済み |
| **テスト手順** | **各ブラウザで以下を実行:**<br>&nbsp;&nbsp;1. Chrome最新版<br>&nbsp;&nbsp;2. Edge最新版<br>&nbsp;&nbsp;3. Firefox最新版<br>&nbsp;&nbsp;4. Safari最新版<br><br>**実施内容:**<br>&nbsp;&nbsp;1-1. アプリケーションにアクセス<br>&nbsp;&nbsp;1-2. ToDo作成→一覧表示→詳細表示→更新→削除の一連のフローを実行<br>&nbsp;&nbsp;1-3. ラベル機能を使用<br>&nbsp;&nbsp;1-4. 検索・絞込機能を使用<br>&nbsp;&nbsp;1-5. すべての機能が正常に動作することを確認<br>&nbsp;&nbsp;1-6. レイアウト崩れがないことを確認<br>&nbsp;&nbsp;1-7. JavaScriptエラーがコンソールに表示されないことを確認 |
| **期待結果** | ・すべてのブラウザで動作する<br>・レイアウトが一貫している<br>・JavaScriptエラーが発生しない<br>・CSS適用が正しい<br>・パフォーマンスが許容範囲内 |
| **確認ポイント** | ・Angularのブラウザサポートポリシーに準拠していること<br>・polyfillが適切に設定されていること<br>・ベンダープレフィックスが必要な場合は設定されていること<br>・Autoprefixerが機能していること |
| **関連要件** | REQ-USE-002 |

#### TC-IT-402: アクセシビリティ検証（WCAG 2.1 Level AA）

| 項目 | 内容 |
|---|---|
| **対象要件** | REQ-USE-008 |
| **目的** | WCAG 2.1 Level AA準拠を検証 |
| **前提条件** | アプリケーションが稼働中 |
| **テスト手順** | **1. 自動テスト（axe DevTools）**<br>&nbsp;&nbsp;1-1. Chrome拡張機能「axe DevTools」をインストール<br>&nbsp;&nbsp;1-2. 各画面でaxeを実行<br>&nbsp;&nbsp;1-3. 検出された問題を確認<br>&nbsp;&nbsp;1-4. スコアが90点以上であることを確認<br><br>**2. Lighthouseアクセシビリティ監査**<br>&nbsp;&nbsp;2-1. Chrome DevToolsでLighthouseを実行<br>&nbsp;&nbsp;2-2. Accessibilityスコアを確認<br>&nbsp;&nbsp;2-3. スコアが90点以上であることを確認<br><br>**3. キーボードナビゲーション**<br>&nbsp;&nbsp;3-1. マウスを使わずにTabキーで全要素に移動<br>&nbsp;&nbsp;3-2. フォーカスインジケーターが視覚的に明確であることを確認<br>&nbsp;&nbsp;3-3. Enterキーでボタン操作が可能であることを確認<br>&nbsp;&nbsp;3-4. Escキーでダイアログが閉じることを確認<br><br>**4. スクリーンリーダー（NVDA/JAWS）**<br>&nbsp;&nbsp;4-1. スクリーンリーダーを起動<br>&nbsp;&nbsp;4-2. ToDo一覧を読み上げ<br>&nbsp;&nbsp;4-3. ラベルやボタンが適切に読み上げられることを確認<br>&nbsp;&nbsp;4-4. ARIA属性が適切に設定されていることを確認<br><br>**5. 色覚異常シミュレーション**<br>&nbsp;&nbsp;5-1. Chrome DevToolsの「Rendering」タブを開く<br>&nbsp;&nbsp;5-2. 「Emulate vision deficiencies」で各種色覚異常をシミュレート<br>&nbsp;&nbsp;5-3. ステータスの色がアイコンでも識別可能であることを確認<br>&nbsp;&nbsp;5-4. コントラスト比が4.5:1以上であることを確認<br><br>**6. テキストサイズ変更**<br>&nbsp;&nbsp;6-1. ブラウザのズームを200%に設定<br>&nbsp;&nbsp;6-2. レイアウト崩れがないことを確認<br>&nbsp;&nbsp;6-3. すべてのテキストが読み取り可能であることを確認 |
| **期待結果** | ・axeスコア ≥ 90点<br>・Lighthouseアクセシビリティスコア ≥ 90点<br>・すべての要素がキーボードでアクセス可能<br>・フォーカスインジケーターが明確<br>・スクリーンリーダーで適切に読み上げられる<br>・色だけに依存しない情報伝達（アイコン併用）<br>・コントラスト比 ≥ 4.5:1（WCAG AA）<br>・200%ズームでも使用可能 |
| **確認ポイント** | ・ARIA属性（role、aria-label、aria-describedby等）が適切に設定されていること<br>・セマンティックHTML（header、nav、main、article等）が使用されていること<br>・フォームにlabel要素が関連付けられていること<br>・画像にalt属性が設定されていること<br>・キーボードトラップが発生しないこと |
| **テストツール** | ・axe DevTools<br>・Lighthouse<br>・WAVE (Web Accessibility Evaluation Tool)<br>・NVDA/JAWS (スクリーンリーダー)<br>・Color Contrast Analyzer |
| **関連要件** | REQ-USE-008, REQ-FUNC-007 |


#### TC-IT-403: キーボードショートカット検証

| 項目 | 内容 |
|---|---|
| **対象要件** | REQ-USE-007 |
| **目的** | キーボードショートカットが正しく機能することを検証 |
| **前提条件** | アプリケーションが稼働中 |
| **テスト手順** | **1. ToDo作成ショートカット（Ctrl+N）**<br>&nbsp;&nbsp;1-1. 一覧画面でCtrl+Nを押下<br>&nbsp;&nbsp;1-2. ToDo作成画面が表示されることを確認<br><br>**2. 検索ショートカット（Ctrl+F）**<br>&nbsp;&nbsp;2-1. 一覧画面でCtrl+Fを押下<br>&nbsp;&nbsp;2-2. 検索ボックスにフォーカスが移動することを確認<br><br>**3. 保存ショートカット（Ctrl+S）**<br>&nbsp;&nbsp;3-1. ToDo編集画面でCtrl+Sを押下<br>&nbsp;&nbsp;3-2. 保存が実行されることを確認<br>&nbsp;&nbsp;3-3. ブラウザのデフォルト保存ダイアログが表示されないことを確認（preventDefault）<br><br>**4. ヘルプ画面**<br>&nbsp;&nbsp;4-1. ヘルプボタンをクリック<br>&nbsp;&nbsp;4-2. ショートカット一覧が表示されることを確認<br>&nbsp;&nbsp;4-3. すべてのショートカットが記載されていることを確認 |
| **期待結果** | ・Ctrl+N: ToDo作成画面を開く<br>・Ctrl+F: 検索ボックスにフォーカス<br>・Ctrl+S: 保存実行（ブラウザのデフォルト動作を抑制）<br>・ヘルプ画面にショートカット一覧が表示される<br>・Macでは⌘キーで同様に機能する |
| **確認ポイント** | ・Angular HostListenerでキーイベントがキャプチャされていること<br>・event.preventDefault()でブラウザのデフォルト動作が抑制されていること<br>・ショートカットが直感的で一般的な慣習に従っていること |
| **関連要件** | REQ-USE-007 |

---

## 6. エラーハンドリングテスト

### 6.1 ネットワークエラー処理

#### TC-IT-500: ネットワークエラー時の挙動

| 項目 | 内容 |
|---|---|
| **対象要件** | REQ-FUNC-001, 004, 005, REQ-USE-005, REQ-REL-004 |
| **目的** | ネットワークエラー時に適切なエラーメッセージが表示され、システムが安定することを検証 |
| **前提条件** | アプリケーションが稼働中 |
| **テスト手順** | **1. ネットワーク切断シミュレーション**<br>&nbsp;&nbsp;1-1. Chrome DevToolsのNetworkタブでOfflineモードを有効化<br>&nbsp;&nbsp;1-2. ToDoを作成して保存を試行<br>&nbsp;&nbsp;1-3. エラーメッセージが表示されることを確認<br>&nbsp;&nbsp;1-4. アプリケーションがクラッシュしないことを確認<br><br>**2. タイムアウトシミュレーション**<br>&nbsp;&nbsp;2-1. Chrome DevToolsのNetworkタブで「Slow 3G」を選択<br>&nbsp;&nbsp;2-2. ToDo一覧取得を実行<br>&nbsp;&nbsp;2-3. タイムアウト時にエラーメッセージが表示されることを確認<br>&nbsp;&nbsp;2-4. ローディングインジケーターが表示されることを確認<br><br>**3. サーバーダウンシミュレーション**<br>&nbsp;&nbsp;3-1. バックエンドAPIを停止<br>&nbsp;&nbsp;3-2. フロントエンドでToDo操作を試行<br>&nbsp;&nbsp;3-3. 適切なエラーメッセージが表示されることを確認<br>&nbsp;&nbsp;3-4. 「再試行」ボタンが提供されることを確認<br><br>**4. ネットワーク復旧後の動作**<br>&nbsp;&nbsp;4-1. ネットワークを復旧<br>&nbsp;&nbsp;4-2. 「再試行」ボタンをクリック<br>&nbsp;&nbsp;4-3. 正常に処理が再開されることを確認 |
| **期待結果** | ・ネットワークエラー時に明確なエラーメッセージが表示される<br>・エラーメッセージ例: 「接続エラーが発生しました。ネットワークを確認してください」<br>・アプリケーションがクラッシュしない<br>・ローディングインジケーターが表示される<br>・再試行オプションが提供される<br>・ネットワーク復旧後に正常動作する |
| **確認ポイント** | ・Angular HttpInterceptorでエラーハンドリングが実装されていること<br>・RxJSのcatchError、retry演算子が使用されていること<br>・ユーザーフレンドリーなエラーメッセージ（REQ-USE-005） |
| **関連要件** | REQ-USE-005, REQ-REL-004 |

### 6.2 サーバーエラー処理

#### TC-IT-510: 500番台サーバーエラーのハンドリング

| 項目 | 内容 |
|---|---|
| **対象要件** | REQ-REL-004, REQ-USE-005 |
| **目的** | サーバーエラー時に適切なエラーハンドリングが行われることを検証 |
| **前提条件** | アプリケーションが稼働中 |
| **テスト手順** | **1. 500 Internal Server Errorシミュレーション**<br>&nbsp;&nbsp;1-1. バックエンドコードを一時的に修正して例外を発生させる<br>&nbsp;&nbsp;1-2. フロントエンドからAPIを呼び出し<br>&nbsp;&nbsp;1-3. エラーメッセージが表示されることを確認<br>&nbsp;&nbsp;1-4. エラーがユーザーに適切に伝わることを確認<br><br>**2. エラーログの記録**<br>&nbsp;&nbsp;2-1. サーバーログを確認<br>&nbsp;&nbsp;2-2. エラー詳細（スタックトレース）が記録されていることを確認<br>&nbsp;&nbsp;2-3. ユーザーには技術的詳細が表示されないことを確認<br><br>**3. グローバルエラーハンドラー**<br>&nbsp;&nbsp;3-1. 予期しない例外を発生させる<br>&nbsp;&nbsp;3-2. アプリケーションがクラッシュせず、エラー画面が表示されることを確認 |
| **期待結果** | ・500エラー時にユーザーフレンドリーなメッセージが表示される<br>・エラーメッセージ例: 「サーバーエラーが発生しました。しばらく待ってから再度お試しください」<br>・技術的詳細（スタックトレース）はユーザーに表示されない<br>・サーバーログにエラー詳細が記録される<br>・アプリケーションが安定している |
| **確認ポイント** | ・ASP.NET CoreのGlobal Exception Handlerが実装されていること<br>・ErrorControllerまたはExceptionMiddlewareが設定されていること<br>・ログライブラリ（Serilog、NLog等）が使用されていること<br>・本番環境でスタックトレースが隠蔽されていること |
| **関連要件** | REQ-REL-004, 005, REQ-USE-005 |

---

## 7. 外部連携テスト

### 7.1 データベース連携テスト

#### TC-IT-600: データベース接続障害時の挙動

| 項目 | 内容 |
|---|---|
| **対象要件** | REQ-REL-001, 004 |
| **目的** | データベース接続障害時にシステムが適切に処理することを検証 |
| **前提条件** | アプリケーションが稼働中 |
| **テスト手順** | **1. DB接続文字列の一時的な無効化**<br>&nbsp;&nbsp;1-1. appsettings.jsonの接続文字列を無効なものに変更<br>&nbsp;&nbsp;1-2. アプリケーションを再起動<br>&nbsp;&nbsp;1-3. APIリクエストを送信<br>&nbsp;&nbsp;1-4. 503 Service Unavailableまたは500エラーが返されることを確認<br>&nbsp;&nbsp;1-5. エラーログにDB接続エラーが記録されることを確認<br><br>**2. DB再接続の確認**<br>&nbsp;&nbsp;2-1. 接続文字列を正しいものに戻す<br>&nbsp;&nbsp;2-2. アプリケーションを再起動（またはホットリロード）<br>&nbsp;&nbsp;2-3. 正常に動作することを確認<br><br>**3. 接続プールの検証**<br>&nbsp;&nbsp;3-1. 大量のリクエストを同時送信<br>&nbsp;&nbsp;3-2. 接続プールが適切に管理されることを確認<br>&nbsp;&nbsp;3-3. 接続リークが発生しないことを確認 |
| **期待結果** | ・DB接続障害時に適切なエラーが返される<br>・ユーザーに技術的詳細が露出しない<br>・エラーログに詳細が記録される<br>・接続復旧後に正常動作する<br>・接続プールが適切に機能する |
| **確認ポイント** | ・Entity Framework CoreのDbContextが適切に設定されていること<br>・接続プール設定が適切であること<br>・Dispose()が適切に呼ばれていること（using文またはDI） |
| **関連要件** | REQ-REL-001, 004 |

---

## 8. エンドツーエンド業務フローテスト

### 8.1 実業務シナリオ

#### TC-IT-700: 1日の業務フロー統合シナリオ

| 項目 | 内容 |
|---|---|
| **対象要件** | すべての機能要件（REQ-FUNC-001～017） |
| **目的** | 実際のユーザー利用シナリオでシステム全体が正しく機能することを検証 |
| **前提条件** | ・アプリケーションが稼働中<br>・初期データとして10件のToDoと5件のラベルが存在 |
| **テスト手順** | **朝の業務開始（9:00）**<br>&nbsp;&nbsp;1. アプリケーションにアクセス<br>&nbsp;&nbsp;2. 今日のタスク一覧を確認（日時絞込使用）<br>&nbsp;&nbsp;3. ステータスフィルターで「未着手」のみを表示<br><br>**新しいタスク追加（9:15）**<br>&nbsp;&nbsp;4. 「朝会の準備」というToDoを作成<br>&nbsp;&nbsp;5. 「仕事」「重要」ラベルを設定<br>&nbsp;&nbsp;6. ステータスを「着手中」に設定<br><br>**タスク実行（10:00）**<br>&nbsp;&nbsp;7. 「朝会の準備」の詳細画面を開く<br>&nbsp;&nbsp;8. 内容に議事録を追記<br>&nbsp;&nbsp;9. 保存して一覧に戻る<br><br>**タスク完了（11:00）**<br>&nbsp;&nbsp;10. 「朝会の準備」のステータスを「完了」に変更<br>&nbsp;&nbsp;11. 完了したタスクが緑色で表示されることを確認<br><br>**進捗確認（12:00）**<br>&nbsp;&nbsp;12. ステータスフィルターで「完了」を選択<br>&nbsp;&nbsp;13. 本日完了したタスクの件数を確認<br><br>**午後の業務（13:00）**<br>&nbsp;&nbsp;14. 新しいプロジェクトのため「プロジェクトX」ラベルを作成（青色）<br>&nbsp;&nbsp;15. 5件のToDoを作成し、すべてに「プロジェクトX」ラベルを設定<br><br>**検索機能活用（15:00）**<br>&nbsp;&nbsp;16. 「プロジェクト」というキーワードで検索<br>&nbsp;&nbsp;17. 関連するToDoがすべてヒットすることを確認<br><br>**不要タスク削除（17:00）**<br>&nbsp;&nbsp;18. 放棄したタスクを削除<br>&nbsp;&nbsp;19. 確認ダイアログで削除を確定<br><br>**業務終了時の確認（18:00）**<br>&nbsp;&nbsp;20. すべてのステータスで一覧表示<br>&nbsp;&nbsp;21. 今日の活動をレビュー<br>&nbsp;&nbsp;22. 翌日のタスクを確認 |
| **期待結果** | ・すべての操作が正常に完了する<br>・データの整合性が保たれる<br>・レスポンスタイムが許容範囲内<br>・ユーザー体験がスムーズ<br>・エラーが発生しない |
| **確認ポイント** | ・実業務での使用感<br>・機能間の連携がスムーズ<br>・データが正しく保存・更新・削除される<br>・パフォーマンスが快適 |
| **関連要件** | REQ-FUNC-001～017, すべての非機能要件 |

---

## 9. トレーサビリティマトリクス

### 9.1 要件→テストケースマッピング

| 要件ID | 要件名 | テストケースID |
|---|---|---|
| **機能要件** | | |
| REQ-FUNC-001 | ToDo作成 | TC-IT-001, 002, 100, 700 |
| REQ-FUNC-002 | ToDo一覧表示 | TC-IT-001, 201, 700 |
| REQ-FUNC-003 | ToDo詳細表示 | TC-IT-001, 200, 700 |
| REQ-FUNC-004 | ToDo更新 | TC-IT-001, 101, 200, 700 |
| REQ-FUNC-005 | ToDo削除 | TC-IT-001, 120, 700 |
| REQ-FUNC-006 | ステータス設定 | TC-IT-010, 700 |
| REQ-FUNC-007 | ステータス表示 | TC-IT-010, 402, 700 |
| REQ-FUNC-008 | ラベル作成 | TC-IT-020, 021, 700 |
| REQ-FUNC-009 | ラベル一覧表示 | TC-IT-020, 700 |
| REQ-FUNC-010 | ラベル更新 | TC-IT-020, 700 |
| REQ-FUNC-011 | ラベル削除 | TC-IT-020, 110, 700 |
| REQ-FUNC-012 | ToDoへのラベル設定 | TC-IT-020, 100, 700 |
| REQ-FUNC-013 | ラベルによる絞込 | TC-IT-020, 030, 700 |
| REQ-FUNC-014 | 日時による絞込 | TC-IT-030, 700 |
| REQ-FUNC-015 | ステータスによる絞込 | TC-IT-010, 030, 700 |
| REQ-FUNC-016 | キーワード検索 | TC-IT-030, 031, 204, 700 |
| REQ-FUNC-017 | 複合絞込 | TC-IT-030, 700 |
| **性能要件** | | |
| REQ-PERF-001 | API応答時間（単一ToDo） | TC-IT-200 |
| REQ-PERF-002 | API応答時間（一覧取得） | TC-IT-201 |
| REQ-PERF-003 | 画面初期表示時間 | TC-IT-202 |
| REQ-PERF-004 | 画面遷移時間 | TC-IT-001, 700 |
| REQ-PERF-005 | 同時接続ユーザー数 | TC-IT-203 |
| REQ-PERF-006 | データベーステーブルサイズ | TC-IT-204 |
| REQ-PERF-007 | 検索処理時間 | TC-IT-031 |
| REQ-PERF-008 | 大規模データ検索 | TC-IT-204 |
| **セキュリティ要件** | | |
| REQ-SEC-001 | SQLインジェクション対策 | TC-IT-300 |
| REQ-SEC-002 | XSS対策 | TC-IT-301 |
| REQ-SEC-003 | CSRF対策 | TC-IT-302 |
| REQ-SEC-004 | HTTPS通信 | TC-IT-303 |
| REQ-SEC-005 | 入力値検証 | TC-IT-002, 021, 304 |
| REQ-SEC-006 | APIレート制限 | TC-IT-305 |
| **ユーザビリティ要件** | | |
| REQ-USE-001 | レスポンシブデザイン | TC-IT-400 |
| REQ-USE-002 | ブラウザ対応 | TC-IT-401 |
| REQ-USE-003 | 画面解像度 | TC-IT-400 |
| REQ-USE-004 | 学習容易性 | TC-IT-700（実業務フロー） |
| REQ-USE-005 | エラーメッセージ | TC-IT-002, 500, 510 |
| REQ-USE-006 | 入力補助 | TC-IT-002 |
| REQ-USE-007 | キーボードショートカット | TC-IT-403 |
| REQ-USE-008 | アクセシビリティ | TC-IT-402 |
| **信頼性要件** | | |
| REQ-REL-001 | システム稼働率 | TC-IT-600 |
| REQ-REL-002 | データ損失 | TC-IT-100, 101, 120 |
| REQ-REL-004 | エラーハンドリング | TC-IT-500, 510 |
| REQ-REL-005 | ログ記録 | TC-IT-510 |

### 9.2 テストカバレッジサマリー

| カテゴリ | 要件数 | テストケース数 | カバレッジ |
|---|---|---|---|
| 機能要件 | 17件 | 8シナリオ | 100% |
| 性能要件 | 8件 | 5シナリオ | 100% |
| セキュリティ要件 | 6件 | 6シナリオ | 100% |
| ユーザビリティ要件 | 8件 | 4シナリオ | 100% |
| 信頼性要件 | 4件 | 4シナリオ | 100% |
| **合計** | **43件** | **27シナリオ** | **100%** |

---

## 10. テスト実施ガイドライン

### 10.1 テスト実行順序

1. **フェーズ1: 基本機能統合テスト**（TC-IT-001～031）
   - ToDo CRUD統合
   - ステータス・ラベル機能
   - 検索・絞込機能

2. **フェーズ2: データ整合性テスト**（TC-IT-100～120）
   - トランザクション整合性
   - 外部キー制約
   - 論理削除

3. **フェーズ3: 非機能要件テスト**（TC-IT-200～403）
   - 性能テスト
   - セキュリティテスト
   - ユーザビリティテスト

4. **フェーズ4: エラーハンドリング・外部連携**（TC-IT-500～600）
   - ネットワークエラー
   - サーバーエラー
   - DB連携

5. **フェーズ5: エンドツーエンドテスト**（TC-IT-700）
   - 実業務シナリオ

### 10.2 テスト環境セットアップ

```bash
# 1. データベースの初期化
dotnet ef database drop --force
dotnet ef database update

# 2. テストデータの投入
dotnet run --project TestDataGenerator

# 3. バックエンドの起動
cd src/todo-app/api
dotnet run

# 4. フロントエンドの起動
cd src/todo-app/front
ng serve

# 5. フルテキストインデックスの構築（大規模テスト用）
sqlcmd -S localhost -i scripts/setup-fulltext-index.sql
```

### 10.3 合格基準

| カテゴリ | 合格基準 |
|---|---|
| **機能要件** | すべてのテストケースが合格 |
| **性能要件** | 95パーセンタイルが目標値以内 |
| **セキュリティ要件** | すべての攻撃が防御される |
| **ユーザビリティ要件** | 自動テストスコア ≥ 90点 |
| **エラーハンドリング** | 適切なエラーメッセージ表示 |
| **データ整合性** | データ不整合ゼロ |

### 10.4 不具合管理

| 重要度 | 定義 | 対応 |
|---|---|---|
| **Critical** | システムが使用不可、データ損失 | 即時修正 |
| **High** | 主要機能が動作しない | 1週間以内に修正 |
| **Medium** | 一部機能に影響 | 2週間以内に修正 |
| **Low** | UIの軽微な問題 | 次回リリースで修正 |

---

## 11. 改訂履歴

| バージョン | 日付 | 変更内容 | 作成者 |
|---|---|---|---|
| 1.0 | 2025-01-31 | 初版作成。機能要件17件、非機能要件26件をカバーする27の統合テストシナリオを作成 | AI Agent |

---

## 付録A: テストデータ生成スクリプト

```csharp
// TestDataGenerator.cs
public class TestDataGenerator
{
    public async Task GenerateBasicData(TodoDbContext context)
    {
        // ラベル作成
        var labels = new List<LabelEntity>
        {
            new() { LabelName = "仕事", Color = "#FF5733" },
            new() { LabelName = "個人", Color = "#33FF57" },
            new() { LabelName = "重要", Color = "#FF0000" },
            new() { LabelName = "低優先度", Color = "#CCCCCC" }
        };
        context.Labels.AddRange(labels);
        await context.SaveChangesAsync();

        // ToDo作成（100件）
        var random = new Random();
        for (int i = 1; i <= 100; i++)
        {
            var todo = new TodoEntity
            {
                Title = $"テストToDo {i}",
                Content = $"これはテストデータです。番号: {i}",
                Status = (TodoStatus)(i % 4),
                CreatedAt = DateTime.UtcNow.AddDays(-random.Next(0, 30))
            };
            context.Todos.Add(todo);
        }
        await context.SaveChangesAsync();
    }

    public async Task GenerateLargeScaleData(TodoDbContext context, int count = 1000000)
    {
        // 100万件のテストデータ生成（性能テスト用）
        // バッチ処理で挿入
        const int batchSize = 10000;
        for (int i = 0; i < count; i += batchSize)
        {
            var todos = Enumerable.Range(i, Math.Min(batchSize, count - i))
                .Select(j => new TodoEntity
                {
                    Title = $"大規模テストToDo {j}",
                    Content = $"性能テスト用データ {j}",
                    Status = (TodoStatus)(j % 4),
                    CreatedAt = DateTime.UtcNow.AddDays(-j % 365)
                }).ToList();
            
            context.Todos.AddRange(todos);
            await context.SaveChangesAsync();
            context.ChangeTracker.Clear(); // メモリ解放
        }
    }
}
```

---

**本結合テストシナリオは、高機能ToDoアプリケーションの品質を保証するための包括的なテスト計画を提供します。すべてのテストケースを実施することで、システムが要求仕様を満たし、安定して動作することを確認できます。**

