#!/usr/bin/env bash
# =============================================================================
# scanner-entrypoint.sh
#
# 統合脆弱性スキャナーエントリポイント
#
# 使用方法:
#   scanner-entrypoint.sh <command> [options]
#
# コマンド:
#   help          - ヘルプを表示
#   all           - 全スキャンを順次実行
#   nmap          - Nmap ネットワークスキャン
#   nikto         - Nikto Webサーバースキャン
#   zap-baseline  - OWASP ZAP ベースラインスキャン
#   zap-full      - OWASP ZAP フルスキャン（アクティブ攻撃込み）
#   zap-api       - OWASP ZAP APIスキャン
#   sqlmap        - sqlmap SQLインジェクションスキャン
#   trivy         - Trivy ファイルシステムスキャン
#   orchestrate   - Copilot CLI で vuln-scan-orchestrator を実行
#   copilot       - Copilot CLI インタラクティブモード
#   shell         - bash シェルを起動
# =============================================================================
set -euo pipefail

# --- 色付き出力 ---
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

log_info()  { echo -e "${CYAN}[INFO]${NC}  $*"; }
log_ok()    { echo -e "${GREEN}[OK]${NC}    $*"; }
log_warn()  { echo -e "${YELLOW}[WARN]${NC}  $*"; }
log_error() { echo -e "${RED}[ERROR]${NC} $*"; }

# --- 環境変数デフォルト ---
SCAN_TARGET_FRONTEND="${SCAN_TARGET_FRONTEND:-http://frontend:80}"
SCAN_TARGET_API="${SCAN_TARGET_API:-http://api:5000}"
SCAN_TARGET_DB="${SCAN_TARGET_DB:-db}"
SCAN_TARGET_OPENAPI="${SCAN_TARGET_OPENAPI:-http://api:5000/openapi/v1.json}"
SQLMAP_TARGET_URL="${SQLMAP_TARGET_URL:-http://api:5000/api/users?search=test}"
REPORT_DIR="${REPORT_DIR:-/reports}"
DOCKER_WORK_DIR="${DOCKER_WORK_DIR:-/docker-work-dir}"

TIMESTAMP="$(date +%Y%m%d_%H%M%S)"

# =============================================================================
# ヘルスチェック: スキャン対象の到達性確認
# =============================================================================
wait_for_target() {
  local url="$1"
  local name="$2"
  local max_retries="${3:-30}"
  local retry=0

  log_info "${name} の応答待機中: ${url}"
  while [ $retry -lt "$max_retries" ]; do
    if curl -sf -o /dev/null --connect-timeout 3 "$url" 2>/dev/null; then
      log_ok "${name} 応答確認"
      return 0
    fi
    retry=$((retry + 1))
    sleep 2
  done
  log_error "${name} 応答タイムアウト (${max_retries} 回リトライ)"
  return 1
}

# =============================================================================
# Nmap ネットワークスキャン
# =============================================================================
run_nmap() {
  log_info "=== Nmap ネットワークスキャン開始 ==="
  mkdir -p "${REPORT_DIR}/nmap"

  # サービスバージョン検出 + 脆弱性スクリプト
  nmap -sV -sC --script=vuln,ssl-enum-ciphers \
    -p 80,5000,5432 \
    -oN "${REPORT_DIR}/nmap/nmap-report.txt" \
    -oX "${REPORT_DIR}/nmap/nmap-report.xml" \
    frontend api "${SCAN_TARGET_DB}" \
    2>&1 | tee "${REPORT_DIR}/nmap/nmap-output-${TIMESTAMP}.log" || true

  log_ok "Nmap スキャン完了: ${REPORT_DIR}/nmap/"
}

# =============================================================================
# Nikto Webサーバースキャン
# =============================================================================
run_nikto() {
  log_info "=== Nikto Webサーバースキャン開始 ==="
  mkdir -p "${REPORT_DIR}/nikto"

  # Frontend スキャン
  log_info "Nikto: Frontend スキャン"
  nikto -h "${SCAN_TARGET_FRONTEND}" \
    -Format htm \
    -output "${REPORT_DIR}/nikto/nikto-frontend-report.html" \
    -Tuning x 2 3 4 5 \
    -nointeractive \
    -maxtime 300 \
    2>&1 | tee "${REPORT_DIR}/nikto/nikto-frontend-${TIMESTAMP}.log" || true

  # API スキャン
  log_info "Nikto: API スキャン"
  nikto -h "${SCAN_TARGET_API}" \
    -Format htm \
    -output "${REPORT_DIR}/nikto/nikto-api-report.html" \
    -Tuning x 2 3 4 5 \
    -nointeractive \
    -maxtime 300 \
    2>&1 | tee "${REPORT_DIR}/nikto/nikto-api-${TIMESTAMP}.log" || true

  log_ok "Nikto スキャン完了: ${REPORT_DIR}/nikto/"
}

# =============================================================================
# OWASP ZAP ベースラインスキャン（パッシブ）
# =============================================================================
run_zap_baseline() {
  log_info "=== OWASP ZAP ベースラインスキャン開始 ==="
  mkdir -p "${REPORT_DIR}/zap"

  python3 /opt/zap/zap-baseline.py \
    -t "${SCAN_TARGET_FRONTEND}" \
    -J "${REPORT_DIR}/zap/zap-baseline-report.json" \
    -r "${REPORT_DIR}/zap/zap-baseline-report.html" \
    -l WARN \
    -I \
    2>&1 | tee "${REPORT_DIR}/zap/zap-baseline-${TIMESTAMP}.log" || true

  log_ok "ZAP ベースラインスキャン完了: ${REPORT_DIR}/zap/"
}

# =============================================================================
# OWASP ZAP フルスキャン（アクティブ攻撃込み）
# =============================================================================
run_zap_full() {
  log_info "=== OWASP ZAP フルスキャン開始（長時間） ==="
  mkdir -p "${REPORT_DIR}/zap"

  python3 /opt/zap/zap-full-scan.py \
    -t "${SCAN_TARGET_FRONTEND}" \
    -J "${REPORT_DIR}/zap/zap-full-report.json" \
    -r "${REPORT_DIR}/zap/zap-full-report.html" \
    -l WARN \
    -I \
    2>&1 | tee "${REPORT_DIR}/zap/zap-full-${TIMESTAMP}.log" || true

  log_ok "ZAP フルスキャン完了: ${REPORT_DIR}/zap/"
}

# =============================================================================
# OWASP ZAP APIスキャン
# =============================================================================
run_zap_api() {
  log_info "=== OWASP ZAP APIスキャン開始 ==="
  mkdir -p "${REPORT_DIR}/zap"

  python3 /opt/zap/zap-api-scan.py \
    -t "${SCAN_TARGET_OPENAPI}" \
    -f openapi \
    -J "${REPORT_DIR}/zap/zap-api-report.json" \
    -r "${REPORT_DIR}/zap/zap-api-report.html" \
    -l WARN \
    -I \
    2>&1 | tee "${REPORT_DIR}/zap/zap-api-${TIMESTAMP}.log" || true

  log_ok "ZAP APIスキャン完了: ${REPORT_DIR}/zap/"
}

# =============================================================================
# sqlmap SQLインジェクションスキャン
# =============================================================================
run_sqlmap() {
  log_info "=== sqlmap SQLインジェクションスキャン開始 ==="
  mkdir -p "${REPORT_DIR}/sqlmap"

  sqlmap -u "${SQLMAP_TARGET_URL}" \
    --batch \
    --level=3 \
    --risk=2 \
    --flush-session \
    --output-dir="${REPORT_DIR}/sqlmap" \
    --technique=BEUSTQ \
    --threads=4 \
    2>&1 | tee "${REPORT_DIR}/sqlmap/sqlmap-${TIMESTAMP}.log" || true

  log_ok "sqlmap スキャン完了: ${REPORT_DIR}/sqlmap/"
}

# =============================================================================
# Trivy ファイルシステムスキャン
# =============================================================================
run_trivy() {
  log_info "=== Trivy ファイルシステムスキャン開始 ==="
  mkdir -p "${REPORT_DIR}/trivy"

  trivy fs /workdir \
    --scanners vuln,secret,misconfig \
    --severity HIGH,CRITICAL \
    --format table \
    --output "${REPORT_DIR}/trivy/trivy-fs-report.txt" \
    2>&1 | tee "${REPORT_DIR}/trivy/trivy-${TIMESTAMP}.log" || true

  # JSON形式でも出力
  trivy fs /workdir \
    --scanners vuln,secret,misconfig \
    --format json \
    --output "${REPORT_DIR}/trivy/trivy-fs-report.json" \
    2>&1 || true

  log_ok "Trivy スキャン完了: ${REPORT_DIR}/trivy/"
}

# =============================================================================
# 全スキャン順次実行
# =============================================================================
run_all() {
  log_info "=========================================="
  log_info "  全スキャン一括実行開始"
  log_info "=========================================="

  # ターゲットの到達性確認
  wait_for_target "${SCAN_TARGET_FRONTEND}" "Frontend" || log_warn "Frontend 到達不可、スキップの可能性あり"
  wait_for_target "${SCAN_TARGET_API}" "API" || log_warn "API 到達不可、スキップの可能性あり"

  run_nmap
  run_trivy
  run_nikto
  run_zap_baseline
  run_zap_api
  run_sqlmap

  log_info "=========================================="
  log_ok "  全スキャン完了"
  log_info "=========================================="
  log_info "レポート出力先: ${REPORT_DIR}/"
  find "${REPORT_DIR}" -type f \( -name "*.txt" -o -name "*.json" -o -name "*.html" -o -name "*.xml" \) \
    -exec ls -lh {} \; 2>/dev/null | sort || true
}

# =============================================================================
# Copilot CLI: vuln-scan-orchestrator 実行（プログラマティックモード）
# =============================================================================
run_orchestrate() {
  log_info "=== Copilot CLI オーケストレーター実行 ==="

  # GH_TOKEN チェック
  if [ -z "${GH_TOKEN:-}" ]; then
    log_error "GH_TOKEN が設定されていません。"
    log_error ".env ファイルに GH_TOKEN を設定するか、-e GH_TOKEN=... で渡してください。"
    exit 1
  fi

  # docker-work-dir の存在確認
  if [ ! -d "${DOCKER_WORK_DIR}" ]; then
    log_error "docker-work-dir が見つかりません: ${DOCKER_WORK_DIR}"
    exit 1
  fi

  # エージェントファイルの存在確認
  if [ ! -f "${DOCKER_WORK_DIR}/.github/agents/vuln-scan-orchestrator.agent.md" ]; then
    log_error "vuln-scan-orchestrator.agent.md が見つかりません"
    exit 1
  fi

  log_info "作業ディレクトリ: ${DOCKER_WORK_DIR}"
  log_info "エージェント一覧:"
  ls -1 "${DOCKER_WORK_DIR}/.github/agents/"*.agent.md 2>/dev/null | sed 's|.*/||'

  # docker-work-dir に移動してコピロットを実行
  cd "${DOCKER_WORK_DIR}"

  # Copilot CLI に信頼フォルダとして明示的な設定
  mkdir -p ~/.copilot
  cat > ~/.copilot/config.json <<EOF
{
  "trusted_folders": ["${DOCKER_WORK_DIR}"]
}
EOF

  log_info "Copilot CLI をプログラマティックモードで起動..."
  log_info "エージェント: vuln-scan-orchestrator"

  # Copilot CLI プログラマティックモード実行
  # --agent: カスタムエージェント指定
  # --allow-all-tools: 全ツール自動承認（ヘッドレス実行に必須）
  # --allow-all-paths: パスアクセス制限解除
  # -p: プログラマティックモードのプロンプト
  copilot \
    --agent=vuln-scan-orchestrator \
    --allow-all-tools \
    --allow-all-paths \
    -p "脆弱性診断を開始してください。

対象環境:
- Frontend: ${SCAN_TARGET_FRONTEND} (ホスト側: http://localhost:3000)
- API: ${SCAN_TARGET_API} (ホスト側: http://localhost:5000)
- Database: ${SCAN_TARGET_DB}:5432 (ホスト側: localhost:15432)
- OpenAPI: ${SCAN_TARGET_OPENAPI}

ソースコード: /workdir/src/
Docker Compose: /workdir/docker-compose.yml
ドキュメント: /workdir/docs/
スキャンレポート出力先: /reports/
診断レポート出力先: ${DOCKER_WORK_DIR}/docs/reports/
進捗管理: ${DOCKER_WORK_DIR}/docs/進捗/

工程管理表を確認し、未完了の工程から順に実行してください。
全工程をヘッドレス・非インタラクティブで実行してください。
ローカルネットワーク内のアプリケーションのみが対象です。外部へのスキャンは絶対に行わないでください。" \
    2>&1 | tee "${REPORT_DIR}/orchestrator-${TIMESTAMP}.log"

  log_ok "オーケストレーター実行完了"
  log_info "診断レポート: ${DOCKER_WORK_DIR}/docs/reports/"
  log_info "進捗管理: ${DOCKER_WORK_DIR}/docs/進捗/"
  log_info "スキャン結果: ${REPORT_DIR}/"
}

# =============================================================================
# Copilot CLI: インタラクティブモード
# =============================================================================
run_copilot() {
  log_info "=== Copilot CLI インタラクティブモード ==="

  # GH_TOKEN チェック
  if [ -z "${GH_TOKEN:-}" ]; then
    log_error "GH_TOKEN が設定されていません。"
    log_error ".env ファイルに GH_TOKEN を設定するか、-e GH_TOKEN=... で渡してください。"
    exit 1
  fi

  if [ -d "${DOCKER_WORK_DIR}" ]; then
    cd "${DOCKER_WORK_DIR}"
    mkdir -p ~/.copilot
    cat > ~/.copilot/config.json <<EOF
{
  "trusted_folders": ["${DOCKER_WORK_DIR}"]
}
EOF
  fi

  exec copilot
}

# =============================================================================
# ヘルプ
# =============================================================================
show_help() {
  cat <<'HELP'
=============================================================================
  統合脆弱性スキャナー + GitHub Copilot CLI
=============================================================================

内包ツール:
  - OWASP ZAP       : Webアプリケーション脆弱性スキャナー
  - Nikto            : Webサーバースキャナー
  - sqlmap           : SQLインジェクション特化スキャナー
  - Nmap             : ネットワーク脆弱性スキャナー
  - Trivy            : コンテナ / ファイルシステム脆弱性スキャナー
  - GitHub Copilot CLI : AI 脆弱性診断オーケストレーター

使用方法:
  docker compose --profile scan run --rm scanner <command>

コマンド:
  help           ヘルプを表示（このメッセージ）
  all            全スキャンを順次実行（Nmap→Trivy→Nikto→ZAP→sqlmap）
  nmap           Nmap ネットワーク・ポートスキャン
  nikto          Nikto Webサーバー設定検査
  zap-baseline   OWASP ZAP ベースラインスキャン（パッシブ）
  zap-full       OWASP ZAP フルスキャン（アクティブ攻撃含む、長時間）
  zap-api        OWASP ZAP APIスキャン（OpenAPI定義ベース）
  sqlmap         sqlmap SQLインジェクション検出
  trivy          Trivy ファイルシステム脆弱性スキャン
  orchestrate    Copilot CLI で全工程オーケストレーション実行
  copilot        Copilot CLI インタラクティブモード
  shell          bash シェルを起動

例:
  # 全スキャン一括実行
  docker compose --profile scan run --rm scanner all

  # 個別スキャン
  docker compose --profile scan run --rm scanner nmap

  # AI オーケストレーター（GH_TOKEN 必須）
  docker compose --profile scan run --rm -e GH_TOKEN=$GH_TOKEN scanner orchestrate

  # Copilot CLI インタラクティブ
  docker compose --profile scan run --rm -it -e GH_TOKEN=$GH_TOKEN scanner copilot

  # シェルに入る
  docker compose --profile scan run --rm -it scanner shell

レポート出力先:
  /reports/          ← スキャンツール生データ
  /docker-work-dir/  ← AI 診断レポート・進捗管理

=============================================================================
HELP
}

# =============================================================================
# メインディスパッチ
# =============================================================================
COMMAND="${1:-help}"

case "${COMMAND}" in
  help)
    show_help
    ;;
  all)
    run_all
    ;;
  nmap)
    wait_for_target "http://${SCAN_TARGET_DB}:5432" "Database" 10 2>/dev/null || true
    run_nmap
    ;;
  nikto)
    wait_for_target "${SCAN_TARGET_FRONTEND}" "Frontend"
    wait_for_target "${SCAN_TARGET_API}" "API"
    run_nikto
    ;;
  zap-baseline|zap)
    wait_for_target "${SCAN_TARGET_FRONTEND}" "Frontend"
    run_zap_baseline
    ;;
  zap-full)
    wait_for_target "${SCAN_TARGET_FRONTEND}" "Frontend"
    run_zap_full
    ;;
  zap-api)
    wait_for_target "${SCAN_TARGET_API}" "API"
    run_zap_api
    ;;
  sqlmap)
    wait_for_target "${SCAN_TARGET_API}" "API"
    run_sqlmap
    ;;
  trivy)
    run_trivy
    ;;
  orchestrate)
    run_orchestrate
    ;;
  copilot)
    run_copilot
    ;;
  shell)
    exec /bin/bash
    ;;
  *)
    log_error "不明なコマンド: ${COMMAND}"
    show_help
    exit 1
    ;;
esac
